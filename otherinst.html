

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Adding arithmetic and local pointer support &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Generating object files" href="genobj.html" />
    <link rel="prev" title="Backend structure" href="backendstructure.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Adding arithmetic and local pointer support</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="backendstructure.html">Backend structure</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="genobj.html">Generating object files</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="adding-arithmetic-and-local-pointer-support">
<span id="sec-addingmoresupport"></span><h1>Adding arithmetic and local pointer support<a class="headerlink" href="#adding-arithmetic-and-local-pointer-support" title="Permalink to this headline">¶</a></h1>
<p>This chapter adds more cpu0 arithmetic instructions support first.
The logic operation <strong>“not”</strong> support and translation in
<a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#operator-not">section Operator “not” !</a>. The <a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#display-llvm-ir-nodes-with-graphviz">section Display llvm IR nodes with Graphviz</a>
will show you the DAG optimization steps and their corresponding <tt class="docutils literal"><span class="pre">llc</span></tt>
display options.
These DAG optimization steps result can be displayed by the graphic tool of
Graphviz which supply very useful information with graphic view.
You will appreciate Graphviz support in debug, we think.
In <a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#adjust-cpu0-instructions">section Adjust cpu0 instructions</a>,
we adjust cpu0 instructions to support some data type for C language.
The <a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#local-variable-pointer">section Local variable pointer</a> introduce you the local variable pointer
translation.
Finally, <a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#operator-mod">section Operator mod, %</a> take care the C operator %.</p>
<div class="section" id="support-arithmetic-instructions">
<h2>Support arithmetic instructions<a class="headerlink" href="#support-arithmetic-instructions" title="Permalink to this headline">¶</a></h2>
<p>Run the Chapter3_5/Cpu0 <tt class="docutils literal"><span class="pre">llc</span></tt> with input file ch4_1_1.bc will get the error as
follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch4_1_1.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>clang -c ch4_1_1.cpp -emit-llvm -o
ch4_1_1.bc
118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>llvm-dis ch4_1_1.bc -o ch4_1_1.ll
118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>cat ch4_1_1.ll
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch4_1_1.bc&#39;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-</span>
<span class="s2">f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:</span>
<span class="s2">32:64-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;x86_64-apple-macosx10.8.0&quot;</span>

define i32 @main<span class="o">()</span> nounwind uwtable ssp <span class="o">{</span>
%1 <span class="o">=</span> alloca i32, align 4
%a <span class="o">=</span> alloca i32, align 4
%b <span class="o">=</span> alloca i32, align 4
%c <span class="o">=</span> alloca i32, align 4
store i32 0, i32* %1
store i32 5, i32* %a, align 4
store i32 2, i32* %b, align 4
store i32 0, i32* %c, align 4
%2 <span class="o">=</span> load i32* %a, align 4
%3 <span class="o">=</span> load i32* %b, align 4
%4 <span class="o">=</span> add nsw i32 %2, %3
store i32 %4, i32* %c, align 4
%5 <span class="o">=</span> load i32* %c, align 4
ret i32 %5
<span class="o">}</span>

118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch4_1_1.bc -o
ch4_1_1.cpu0.s
LLVM ERROR: Cannot <span class="k">select</span>: 0x7ff02102b010: <span class="nv">i32</span> <span class="o">=</span> add 0x7ff02102ae10, ...
...
</pre></div>
</div>
<p>This error says we have not instructions to translate IR DAG node <strong>add</strong>.
The ADDiu instruction is defined for node <strong>add</strong> with operands of 1 register
and 1 immediate.
This node <strong>add</strong> is for 2 registers.
So, appending the following code to Cpu0InstrInfo.td and Cpu0Schedule.td in
Chapter4_1/,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def shamt     : Operand&lt;i32&gt;;
...
// shamt field must fit in 5 bits.
def immZExt5 : ImmLeaf&lt;i32, [{return Imm == (Imm &amp; 0x1f);}]&gt;;
...
// Arithmetic and logical instructions with 3 register operands.
class ArithLogicR&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
    InstrItinClass itin, RegisterClass RC, bit isComm = 0&gt;:
FA&lt;op, (outs RC:$ra), (ins RC:$rb, RC:$rc),
 !strconcat(instr_asm, "\t$ra, $rb, $rc"),
 [(set RC:$ra, (OpNode RC:$rb, RC:$rc))], itin&gt; {
let shamt = 0;
let isCommutable = isComm;  // e.g. add rb rc =  add rc rb
let isReMaterializable = 1;
}

class CmpInstr&lt;bits&lt;8&gt; op, string instr_asm,
    InstrItinClass itin, RegisterClass RC, bit isComm = 0&gt;:
FA&lt;op, (outs RC:$SW), (ins RC:$ra, RC:$rb),
 !strconcat(instr_asm, "\t$ra, $rb"), [], itin&gt; {
let rc = 0;
let shamt = 0;
let isCommutable = isComm;
}
...
// Shifts
class shift_rotate_imm&lt;bits&lt;8&gt; op, bits&lt;4&gt; isRotate, string instr_asm,
       SDNode OpNode, PatFrag PF, Operand ImmOpnd,
       RegisterClass RC&gt;:
FA&lt;op, (outs RC:$ra), (ins RC:$rb, ImmOpnd:$shamt),
 !strconcat(instr_asm, "\t$ra, $rb, $shamt"),
 [(set RC:$ra, (OpNode RC:$rb, PF:$shamt))], IIAlu&gt; {
let rc = isRotate;
let shamt = shamt;
}

// 32-bit shift instructions.
class shift_rotate_imm32&lt;bits&lt;8&gt; func, bits&lt;4&gt; isRotate, string instr_asm,
       SDNode OpNode&gt;:
shift_rotate_imm&lt;func, isRotate, instr_asm, OpNode, immZExt5, shamt, CPURegs&gt;;

// Load Upper Imediate
class LoadUpper&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC, Operand Imm&gt;:
FL&lt;op, (outs RC:$ra), (ins Imm:$imm16),
 !strconcat(instr_asm, "\t$ra, $imm16"), [], IIAlu&gt; {
let rb = 0;
let neverHasSideEffects = 1;
let isReMaterializable = 1;
}
...
/// Arithmetic Instructions (3-Operand, R-Type)
def CMP : CmpInstr&lt;0x10, "cmp", IIAlu, CPURegs, 1&gt;;
def ADD   : ArithLogicR&lt;0x13, "add", add, IIAlu, CPURegs, 1&gt;;
def SUB   : ArithLogicR&lt;0x14, "sub", sub, IIAlu, CPURegs, 1&gt;;
def MUL   : ArithLogicR&lt;0x15, "mul", mul, IIImul, CPURegs, 1&gt;;
def DIV   : ArithLogicR&lt;0x16, "div", sdiv, IIIdiv, CPURegs, 1&gt;;
def UDIV  : ArithLogicR&lt;0x17, "udiv", udiv, IIIdiv, CPURegs, 1&gt;;
def AND   : ArithLogicR&lt;0x18, "and", and, IIAlu, CPURegs, 1&gt;;
def OR    : ArithLogicR&lt;0x19, "or", or, IIAlu, CPURegs, 1&gt;;
def XOR   : ArithLogicR&lt;0x1A, "xor", xor, IIAlu, CPURegs, 1&gt;;

/// Shift Instructions
// sra is IR node for ashr llvm IR instruction of .bc
def SRA   : shift_rotate_imm32&lt;0x1B, 0x00, "sra", sra&gt;;
def ROL   : shift_rotate_imm32&lt;0x1C, 0x01, "rol", rotl&gt;;
def ROR   : shift_rotate_imm32&lt;0x1D, 0x01, "ror", rotr&gt;;
...
// srl is IR node for lshr llvm IR instruction of .bc
def SHR   : shift_rotate_imm32&lt;0x1F, 0x00, "shr", srl&gt;;</pre>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_1/Cpu0Schedule.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="n">def</span> <span class="n">IMULDIV</span> <span class="o">:</span> <span class="n">FuncUnit</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">def</span> <span class="n">IIImul</span>       <span class="o">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="n">def</span> <span class="n">IIIdiv</span>       <span class="o">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html</span>
<span class="n">def</span> <span class="n">Cpu0GenericItineraries</span> <span class="o">:</span> <span class="n">ProcessorItineraries</span><span class="o">&lt;</span><span class="p">[</span><span class="n">ALU</span><span class="p">,</span> <span class="n">IMULDIV</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span>
<span class="p">...</span>
<span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIImul</span>       <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">17</span><span class="p">,</span> <span class="p">[</span><span class="n">IMULDIV</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIIdiv</span>       <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">38</span><span class="p">,</span> <span class="p">[</span><span class="n">IMULDIV</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>In RISC CPU like Mips, the multiply/divide function unit and add/sub/logic unit
are designed from two different hardware circuits, and more, their data path is
separate. We think the cpu0 is the same even though no explanation in it&#8217;s web
site.
So, these two function units can be executed at same time (instruction level
parallelism). Reference <a class="footnote-reference" href="#id8" id="id1">[1]</a> for instruction itineraries.</p>
<p>Now, let&#8217;s build Chapter4_1/ and run with input file ch4_1_2.cpp as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>clang -c ch4_1_2.cpp -emit-llvm -o ch4_1_2.bc
118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>llvm-dis ch4_1_2.bc -o -
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch4_1_2.bc&#39;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-</span>
<span class="s2">f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:</span>
<span class="s2">32:64-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;x86_64-apple-macosx10.8.0&quot;</span>

define i32 @main<span class="o">()</span> nounwind uwtable ssp <span class="o">{</span>
  %1 <span class="o">=</span> alloca i32, align 4
  %a <span class="o">=</span> alloca i32, align 4
  %b <span class="o">=</span> alloca i32, align 4
  %c <span class="o">=</span> alloca i32, align 4
  %d <span class="o">=</span> alloca i32, align 4
  %e <span class="o">=</span> alloca i32, align 4
  %f <span class="o">=</span> alloca i32, align 4
  %g <span class="o">=</span> alloca i32, align 4
  %h <span class="o">=</span> alloca i32, align 4
  %i <span class="o">=</span> alloca i32, align 4
  %j <span class="o">=</span> alloca i32, align 4
  %k <span class="o">=</span> alloca i32, align 4
  %l <span class="o">=</span> alloca i32, align 4
  %a1 <span class="o">=</span> alloca i32, align 4
  %k1 <span class="o">=</span> alloca i32, align 4
  %f1 <span class="o">=</span> alloca i32, align 4
  %j1 <span class="o">=</span> alloca i32, align 4
  store i32 0, i32* %1
  store i32 5, i32* %a, align 4
  store i32 2, i32* %b, align 4
  store i32 0, i32* %c, align 4
  store i32 0, i32* %d, align 4
  store i32 0, i32* %l, align 4
  store i32 -5, i32* %a1, align 4
  store i32 0, i32* %k1, align 4
  store i32 0, i32* %f1, align 4
  %2 <span class="o">=</span> load i32* %a, align 4
  %3 <span class="o">=</span> load i32* %b, align 4
  %4 <span class="o">=</span> add nsw i32 %2, %3
  store i32 %4, i32* %c, align 4
  %5 <span class="o">=</span> load i32* %a, align 4
  %6 <span class="o">=</span> load i32* %b, align 4
  %7 <span class="o">=</span> sub nsw i32 %5, %6
  store i32 %7, i32* %d, align 4
  %8 <span class="o">=</span> load i32* %a, align 4
  %9 <span class="o">=</span> load i32* %b, align 4
  %10 <span class="o">=</span> mul nsw i32 %8, %9
  store i32 %10, i32* %e, align 4
  %11 <span class="o">=</span> load i32* %a, align 4
  %12 <span class="o">=</span> load i32* %b, align 4
  %13 <span class="o">=</span> sdiv i32 %11, %12
  store i32 %13, i32* %f, align 4
  %14 <span class="o">=</span> load i32* %a1, align 4
  %15 <span class="o">=</span> load i32* %b, align 4
  %16 <span class="o">=</span> udiv i32 %14, %15
  store i32 %16, i32* %f1, align 4
  %17 <span class="o">=</span> load i32* %a, align 4
  %18 <span class="o">=</span> load i32* %b, align 4
  %19 <span class="o">=</span> and i32 %17, %18
  store i32 %19, i32* %g, align 4
  %20 <span class="o">=</span> load i32* %a, align 4
  %21 <span class="o">=</span> load i32* %b, align 4
  %22 <span class="o">=</span> or i32 %20, %21
  store i32 %22, i32* %h, align 4
  %23 <span class="o">=</span> load i32* %a, align 4
  %24 <span class="o">=</span> load i32* %b, align 4
  %25 <span class="o">=</span> xor i32 %23, %24
  store i32 %25, i32* %i, align 4
  %26 <span class="o">=</span> load i32* %a, align 4
  %27 <span class="o">=</span> shl i32 %26, 2
  store i32 %27, i32* %j, align 4
  %28 <span class="o">=</span> load i32* %a1, align 4
  %29 <span class="o">=</span> shl i32 %28, 2
  store i32 %29, i32* %j1, align 4
  %30 <span class="o">=</span> load i32* %a, align 4
  %31 <span class="o">=</span> ashr i32 %30, 2
  store i32 %31, i32* %k, align 4
  %32 <span class="o">=</span> load i32* %a1, align 4
  %33 <span class="o">=</span> lshr i32 %32, 2
  store i32 %33, i32* %k1, align 4
  %34 <span class="o">=</span> load i32* %c, align 4
  ret i32 %34
<span class="o">}</span>

118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch4_1_2.bc -o -
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch4_1_2.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,72,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -72
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 72
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 68<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$3</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 2
  st  <span class="nv">$3</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 56<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, -5
  st  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  add <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 56<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  sub <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  mul <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  div <span class="nv">$3</span>, <span class="nv">$2</span>
  mflo  <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  divu  <span class="nv">$3</span>, <span class="nv">$2</span>
  mflo  <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  and <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  or  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  xor <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 2
  st  <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 2
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  sra <span class="nv">$2</span>, <span class="nv">$2</span>, 2
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  shr <span class="nv">$2</span>, <span class="nv">$2</span>, 2
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 56<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 72
  ret <span class="nv">$2</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>This version can process <strong>+, -, *, /, &amp;, |, ^, &lt;&lt;,</strong> and <strong>&gt;&gt;</strong> operators in C
language.
The corresponding llvm IR instructions are <strong>add, sub, mul, sdiv, and, or, xor,
shl, ashr</strong>.
IR instruction <strong>sdiv</strong> stand for signed div while <strong>udiv</strong> is for unsigned div.
The <strong>&#8216;ashr&#8217;</strong> instruction (arithmetic shift right) returns the first operand
shifted to the right a specified number of bits with sign extension.
In brief, we call <strong>ashr</strong> is “shift with sign extension fill”.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>ashr</strong></p>
<dl class="last docutils">
<dt>Example:</dt>
<dd><p class="first">&lt;result&gt; = ashr i32 4, 1   ; yields {i32}:result = 2</p>
<p>&lt;result&gt; = ashr i8 -2, 1   ; yields {i8}:result = -1</p>
<p class="last">&lt;result&gt; = ashr i32 1, 32  ; undefined</p>
</dd>
</dl>
</div>
<p>The C operator <strong>&gt;&gt;</strong> for negative operand is dependent on implementation.
Most compiler translate it into “shift with sign extension fill”, for example,
Mips <strong>sra</strong> is the instruction.
Following is the Micosoft web site explanation,</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>&gt;&gt;</strong>, Microsoft Specific</p>
<p class="last">The result of a right shift of a signed negative quantity is implementation
dependent.
Although Microsoft C++ propagates the most-significant bit to fill vacated
bit positions, there is no guarantee that other implementations will do
likewise.</p>
</div>
<p>In addition to <strong>ashr</strong>, the other instruction “shift with zero filled”
<strong>lshr</strong> in llvm (Mips implement lshr with instruction <strong>srl</strong>) has the
following meaning.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>lshr</strong></p>
<p class="last">Example:
&lt;result&gt; = lshr i8 -2, 1   ; yields {i8}:result = 0x7FFFFFFF</p>
</div>
<p>In llvm, IR node <strong>sra</strong> is defined for ashr IR instruction, node <strong>srl</strong> is
defined for lshr instruction (I don&#8217;t know why don&#8217;t use ashr and lshr as the
IR node name directly). Summary as the Table: C operator &gt;&gt; implementation.</p>
<table border="1" class="docutils">
<caption>C operator &gt;&gt; implementation</caption>
<colgroup>
<col width="40%" />
<col width="22%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Shift with zero filled</th>
<th class="head">Shift with signed extension filled</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>symbol in .bc</td>
<td>lshr</td>
<td>ashr</td>
</tr>
<tr class="row-odd"><td>symbol in IR node</td>
<td>srl</td>
<td>sra</td>
</tr>
<tr class="row-even"><td>Mips instruction</td>
<td>srl</td>
<td>sra</td>
</tr>
<tr class="row-odd"><td>Cpu0 instruction</td>
<td>shr</td>
<td>sra</td>
</tr>
<tr class="row-even"><td>signed example before x &gt;&gt; 1</td>
<td>0xfffffffe i.e. -2</td>
<td>0xfffffffe i.e. -2</td>
</tr>
<tr class="row-odd"><td>signed example after x &gt;&gt; 1</td>
<td>0x7fffffff i.e 2G-1</td>
<td>0xffffffff i.e. -1</td>
</tr>
<tr class="row-even"><td>unsigned example before x &gt;&gt; 1</td>
<td>0xfffffffe i.e. 4G-2</td>
<td>0xfffffffe i.e. 4G-2</td>
</tr>
<tr class="row-odd"><td>unsigned example after x &gt;&gt; 1</td>
<td>0x7fffffff i.e 2G-1</td>
<td>0xffffffff i.e. 4G-1</td>
</tr>
</tbody>
</table>
<p><strong>lshr:</strong> Logical SHift Right</p>
<p><strong>ashr:</strong> Arithmetic SHift right</p>
<p><strong>srl:</strong>  Shift Right Logically</p>
<p><strong>sra:</strong>  Shift Right Arithmetically</p>
<p><strong>shr:</strong>  SHift Right</p>
<p>If we consider the x &gt;&gt; 1 definition is x = x/2 for compiler implementation.
As you can see from Table: C operator &gt;&gt; implementation, <strong>lshr</strong> is failed on
some signed value (such as -2). In the same way, <strong>ashr</strong> is failed on some
unsigned value (such as 4G-2). So, in order to satisfy this definition in
both signed and unsigned integer of x, we need these two instructions,
<strong>lshr</strong> and <strong>ashr</strong>.</p>
<table border="1" class="docutils">
<caption>C operator &lt;&lt; implementation</caption>
<colgroup>
<col width="64%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Shift with zero filled</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>symbol in .bc</td>
<td>shl</td>
</tr>
<tr class="row-odd"><td>symbol in IR node</td>
<td>shl</td>
</tr>
<tr class="row-even"><td>Mips instruction</td>
<td>sll</td>
</tr>
<tr class="row-odd"><td>Cpu0 instruction</td>
<td>shl</td>
</tr>
<tr class="row-even"><td>signed example before x &lt;&lt; 1</td>
<td>0x40000000 i.e. 1G</td>
</tr>
<tr class="row-odd"><td>signed example after x &lt;&lt; 1</td>
<td>0x80000000 i.e -2G</td>
</tr>
<tr class="row-even"><td>unsigned example before x &lt;&lt; 1</td>
<td>0x40000000 i.e. 1G</td>
</tr>
<tr class="row-odd"><td>unsigned example after x &lt;&lt; 1</td>
<td>0x80000000 i.e 2G</td>
</tr>
</tbody>
</table>
<p>Again, consider the x &lt;&lt; 1 definition is x = x*2.
From Table: C operator &lt;&lt; implementation, we see <strong>lshr</strong> satisfy the unsigned
x=1G but failed on signed x=1G. It&#8217;s fine since the 2G is out of 32 bits signed
integer range (-2G ~ 2G-1).
For the overflow case, no way to keep the correct result in register. So, any
value in register is OK. You can check the <strong>lshr</strong> satisfy x = x*2 for x &lt;&lt; 1
when the x result is not out of range, no matter operand x is signed or unsigned
integer.</p>
<p>Micorsoft implementation references as <a class="footnote-reference" href="#id9" id="id2">[2]</a>.</p>
<p>The sub-section &#8220;‘ashr‘ Instruction&#8221; and sub-section &#8220;‘lshr‘ Instruction&#8221; of
<a class="footnote-reference" href="#id10" id="id3">[3]</a>.</p>
<p>The version Chapter4_1 just add 70 lines code in td files.
With these 70 lines code, it process 9 operators more for C language and their
corresponding llvm IR instructions.
The arithmetic instructions are easy to implement by add the definition in td
file only.</p>
<p>Run ch4_1_3.cpp with code Chapter4_1/ which support udiv and sra will get the
result as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch4_1_3.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="n">f1</span> <span class="o">=</span> <span class="n">a1</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-13-40:InputFiles Jonathan<span class="nv">$ </span>clang -c ch4_1_3.cpp -emit-llvm -o ch4_1_3.bc
118-165-13-40:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_1_3.bc -o ch4_1_3.cpu0.s
118-165-13-40:InputFiles Jonathan<span class="nv">$ </span>cat ch4_1_3.cpu0.s
  ...
  udiv    <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  sra <span class="nv">$2</span>, <span class="nv">$2</span>, 2
  ...
</pre></div>
</div>
</div>
<div class="section" id="operator-not">
<h2>Operator “not” !<a class="headerlink" href="#operator-not" title="Permalink to this headline">¶</a></h2>
<p>Files ch4_2.cpp and ch4_2.bc are the C source code for <strong>“not”</strong> boolean operator
and it&#8217;s corresponding llvm IR. List them as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch4_2.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="n">b</span> <span class="o">=</span> <span class="o">!</span><span class="n">a</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-bash"><div class="highlight"><pre>; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch4_2.bc&#39;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-</span>
<span class="s2">f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128-n8:16:32-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;i386-apple-macosx10.8.0&quot;</span>

define i32 @main<span class="o">()</span> nounwind ssp <span class="o">{</span>
entry:
  %retval <span class="o">=</span> alloca i32, align 4
  %a <span class="o">=</span> alloca i32, align 4
  %b <span class="o">=</span> alloca i32, align 4
  store i32 0, i32* %retval
  store i32 5, i32* %a, align 4
  store i32 0, i32* %b, align 4
  %0 <span class="o">=</span> load i32* %a, align 4      // <span class="nv">a</span> <span class="o">=</span> %0
  %tobool <span class="o">=</span> icmp ne i32 %0, 0   // ne: stand <span class="k">for </span>not egual
  %lnot <span class="o">=</span> xor i1 %tobool, <span class="nb">true</span>
  %conv <span class="o">=</span> zext i1 %lnot to i32
  store i32 %conv, i32* %b, align 4
  %1 <span class="o">=</span> load i32* %b, align 4
  ret i32 %1
<span class="o">}</span>
</pre></div>
</div>
<p>As above, b = !a, is translated into (xor (icmp ne i32 %0, 0), true).
The %0 is the virtual register of variable <strong>a</strong> and the result of
(icmp ne i32 %0, 0) is 1 bit size.
To prove the translation is correct.
Let&#8217;s assume %0 != 0 first, then the (icmp ne i32 %0, 0) = 1 (or true), and
(xor 1, 1) = 0.
When %0 = 0, (icmp ne i32 %0, 0) = 0 (or false), and (xor 0, 1) = 1.
So, the translation is correct.</p>
<p>Now, let&#8217;s run ch4_2.bc with Chapter4_1/ with <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt> option to get result
as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-16-22:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -debug -relocation-model<span class="o">=</span>pic
-filetype<span class="o">=</span>asm ch4_3.bc -o ch4_3.cpu0.s
...

<span class="o">===</span> main
Initial selection DAG: BB#0 <span class="s1">&#39;main:entry&#39;</span>
SelectionDAG has 20 nodes:
...
0x7ffb7982ab10: &lt;multiple use&gt;
    0x7ffb7982ab10: &lt;multiple use&gt;
    0x7ffb7982a210: &lt;multiple use&gt;
    0x7ffb7982ac10: <span class="nv">ch</span> <span class="o">=</span> setne <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

  0x7ffb7982ad10: <span class="nv">i1</span> <span class="o">=</span> setcc 0x7ffb7982ab10, 0x7ffb7982a210, 0x7ffb7982ac10
  <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

  0x7ffb7982ae10: <span class="nv">i1</span> <span class="o">=</span> Constant&lt;-1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

  0x7ffb7982af10: <span class="nv">i1</span> <span class="o">=</span> xor 0x7ffb7982ad10, 0x7ffb7982ae10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

0x7ffb7982b010: <span class="nv">i32</span> <span class="o">=</span> zero_extend 0x7ffb7982af10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>
...
Replacing.3 0x7ffb7982af10: <span class="nv">i1</span> <span class="o">=</span> xor 0x7ffb7982ad10, 0x7ffb7982ae10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

With: 0x7ffb7982d210: <span class="nv">i1</span> <span class="o">=</span> setcc 0x7ffb7982ab10, 0x7ffb7982a210, 0x7ffb7982cf10

Optimized lowered selection DAG: BB#0 <span class="s1">&#39;main:&#39;</span>
SelectionDAG has 17 nodes:
...
 0x7ffb7982ab10: &lt;multiple use&gt;
    0x7ffb7982ab10: &lt;multiple use&gt;
    0x7ffb7982a210: &lt;multiple use&gt;
    0x7ffb7982cf10: <span class="nv">ch</span> <span class="o">=</span> seteq

  0x7ffb7982d210: <span class="nv">i1</span> <span class="o">=</span> setcc 0x7ffb7982ab10, 0x7ffb7982a210, 0x7ffb7982cf10

  0x7ffb7982b010: <span class="nv">i32</span> <span class="o">=</span> zero_extend 0x7ffb7982d210 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>
...
Type-legalized selection DAG: BB#0 <span class="s1">&#39;main:entry&#39;</span>
SelectionDAG has 18 nodes:
...
  0x7ffb7982ab10: &lt;multiple use&gt;
    0x7ffb7982ab10: &lt;multiple use&gt;
    0x7ffb7982a210: &lt;multiple use&gt;
    0x7ffb7982cf10: <span class="nv">ch</span> <span class="o">=</span> seteq <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

  0x7ffb7982ac10: <span class="nv">i32</span> <span class="o">=</span> setcc 0x7ffb7982ab10, 0x7ffb7982a210, 0x7ffb7982cf10
   <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

  0x7ffb7982ad10: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;1&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

  0x7ffb7982ae10: <span class="nv">i32</span> <span class="o">=</span> and 0x7ffb7982ac10, 0x7ffb7982ad10 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>
...
ISEL: Starting pattern match on root node: 0x7ffb7982ac10: <span class="nv">i32</span> <span class="o">=</span> setcc
0x7ffb7982ab10, 0x7ffb7982a210, 0x7ffb7982cf10 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>14<span class="o">]</span>

Initial Opcode index to 0
Match failed at index 0
LLVM ERROR: Cannot <span class="k">select</span>: 0x7ffb7982ac10: <span class="nv">i32</span> <span class="o">=</span> setcc 0x7ffb7982ab10,
0x7ffb7982a210, 0x7ffb7982cf10 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>14<span class="o">]</span>
0x7ffb7982ab10: i32,ch <span class="o">=</span> load 0x7ffb7982aa10, 0x7ffb7982a710,
0x7ffb7982a410&lt;LD4<span class="o">[</span>%a<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>4<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>13<span class="o">]</span>
0x7ffb7982a710: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>
0x7ffb7982a410: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>3<span class="o">]</span>
0x7ffb7982a210: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>1<span class="o">]</span>
In <span class="k">function</span>: main
</pre></div>
</div>
<p>Summary as Table: C operator ! corresponding IR of .bc and IR of DAG.</p>
<table border="1" class="docutils">
<caption>C operator ! corresponding IR of .bc and IR of DAG</caption>
<colgroup>
<col width="31%" />
<col width="35%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">IR of .bc</th>
<th class="head">Optimized lowered selection DAG</th>
<th class="head">Type-legalized selection DAG</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>%tobool = icmp ne i32 %0, 0</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>%lnot = xor i1 %tobool, true</td>
<td>%lnot = (setcc %tobool, 0, seteq)</td>
<td>%lnot = (setcc %tobool, 0, seteq)</td>
</tr>
<tr class="row-even"><td>%conv = zext i1 %lnot to i32</td>
<td>%conv = (zero_extend %lnot)</td>
<td>%conv = (and %lnot, 1)</td>
</tr>
</tbody>
</table>
<p>From above DAG translation result of <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt>, we see the IRs are same in both
stages of “Initial selection DAG” and “Optimized lowered selection DAG”.</p>
<p>The (setcc %0, 0, setne) and (xor %tobool, -1) in “Initial selection DAG” stage
corresponding (icmp %0, 0, ne) and (xor %tobool, 1) in ch4_2.bc.
The argument in xor is 1 bit size (1 and -1 are same, they are all represented
by 1).
The (zero_extend %lnot) of “Initial selection DAG” corresponding
(zext i1 %lnot to i32) of ch4_2.bc.
As above it translate 2 DAG nodes (setcc %0, 0, setne) and (xor %tobool, -1)
into 1 DAG node (setcc %tobool, 0, seteq) in “Optimized lowered selection DAG”
stage.
This translation is right since for 1 bit size, (xor %tobool, 1) and
(not %tobool) has same result; and (not (setcc %tobool, 0, setne)) is equal to
(setcc %tobool, 0, seteq).
In “Type-legalized selection DAG” stage, it translate (zero_extern i1
%lnot to 32) into (and %lnot, 1).
(zero_extern i1 %lnot to 32) just expand the %lnot to i32 32 bits result, so
translate into (and %lnot, 1) is correct.</p>
<p>Finally, according the DAG translation message, it fails at
(setcc %tobool, 0, seteq).
Run it with Chapter4_2/ which added code to handle pattern
(setcc %tobool, 0, seteq) as below, to get the following result.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def : Pat&lt;(not CPURegs:$in),
    (XOR CPURegs:$in, (ADDiu ZERO, 1))&gt;;

// setcc patterns
multiclass SeteqPats&lt;RegisterClass RC, Instruction XOROp&gt; {
def : Pat&lt;(seteq RC:$lhs, RC:$rhs),
      (XOROp (XOROp RC:$lhs, RC:$rhs), (ADDiu ZERO, 1))&gt;;
}

defm : SeteqPats&lt;CPURegs, XOR&gt;;</pre>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -debug -filetype<span class="o">=</span>asm ch4_2.bc
-o ch4_2.cpu0.s
...
ISEL: Starting pattern match on root node: 0x7fbc6902ac10: <span class="nv">i32</span> <span class="o">=</span> setcc
0x7fbc6902ab10, 0x7fbc6902a210, 0x7fbc6902cf10 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>14<span class="o">]</span>

Initial Opcode index to 365
Created node: 0x7fbc6902af10: <span class="nv">i32</span> <span class="o">=</span> XOR 0x7fbc6902ab10, 0x7fbc6902a210

Created node: 0x7fbc6902d510: <span class="nv">i32</span> <span class="o">=</span> ADDiu 0x7fbc6902d310, 0x7fbc6902d410

Morphed node: 0x7fbc6902ac10: <span class="nv">i32</span> <span class="o">=</span> XOR 0x7fbc6902af10, 0x7fbc6902d510

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fbc6902ac10: <span class="nv">i32</span> <span class="o">=</span> XOR 0x7fbc6902af10, 0x7fbc6902d510
</pre></div>
</div>
<p>Summary as Table: C operator ! corresponding IR of DAG and .</p>
<table border="1" class="docutils">
<caption>C operator ! corresponding IR of Type-legalized selection DAG
         (include and after this stage) and Cpu0 instructions</caption>
<colgroup>
<col width="64%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Include and after Type-legalized selection DAG</th>
<th class="head">Cpu0 instruction</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>%lnot = (setcc %tobool, 0, seteq)</td>
<td><ul class="first last simple">
<li>%1 = (xor %tobool, 0)</li>
<li>%true = (addiu $r0, 1)</li>
<li>%lnot = (xor %1, %true)</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>%conv = (and %lnot, 1)</td>
<td>%conv = (and %lnot, 1)</td>
</tr>
</tbody>
</table>
<p>Chapter4_2/ defined seteq DAG pattern.
It translate <strong>%lnot = (setcc %tobool, 0, seteq)</strong> into <strong>%1 = (xor %tobool, 0)</strong>,
<strong>%true = (addiu $r0, 1)</strong> and <strong>%lnot = (xor %1, %true)</strong> in
“Instruction selection” stage according the rules defined in Cpu0InstrInfo.td as
above.
This translation is right based on the following truth:</p>
<ol class="arabic simple">
<li>%lnot = 1 when %tobool = 0 and $lnot = 0 when %tobool!=0.</li>
<li>%true = (addiu $r0, 1) always is 1 since $r0 is zero. %tobool is 0 or 1.
When %tobool = 0, %1 = 1 and %lnot = (xor %1, %true) = 0; when %tobool = 1,
%1 = 0 and %lnot = (xor 0, %true) = 1.</li>
<li>When %tobool = !0, %1 != 1 and %lnot = (xor %1, %true) != 0.</li>
</ol>
<p>After xor, the IR (and %lnot, 1) is translated into Cpu0 (and $lnot, 1) which is
defined before.
List the asm file ch4_2.cpu0.s as below, you can check it with
the final result.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-16-22:InputFiles Jonathan<span class="nv">$ </span>cat ch4_2.cpu0.s
...
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 16
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  xor <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 1
  xor <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  and <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  ret <span class="nv">$lr</span>
  ...
</pre></div>
</div>
</div>
<div class="section" id="display-llvm-ir-nodes-with-graphviz">
<h2>Display llvm IR nodes with Graphviz<a class="headerlink" href="#display-llvm-ir-nodes-with-graphviz" title="Permalink to this headline">¶</a></h2>
<p>The previous section, display the DAG translation process in text on terminal
by <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt> option.
The <tt class="docutils literal"><span class="pre">llc</span></tt> also support the graphic display.
The <a class="reference external" href="http://jonathan2251.github.com/lbd/install.html#install-other-tools-on-imac">section Install other tools on iMac</a> mentioned the web for <tt class="docutils literal"><span class="pre">llc</span></tt>
graphic display information.
The <tt class="docutils literal"><span class="pre">llc</span></tt> graphic display with tool Graphviz is introduced in this section.
The graphic display is more readable by eye than display text in terminal.
It&#8217;s not necessary, but helps a lot especially when you are tired in tracking
the DAG translation process.
List the <tt class="docutils literal"><span class="pre">llc</span></tt> graphic support options from the sub-section &#8220;SelectionDAG
Instruction Selection Process&#8221; of web <a class="footnote-reference" href="#id11" id="id4">[4]</a> as follows,</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <tt class="docutils literal"><span class="pre">llc</span></tt> Graphviz DAG display options</p>
<p>-view-dag-combine1-dags displays the DAG after being built, before the
first optimization pass.</p>
<p>-view-legalize-dags displays the DAG before Legalization.</p>
<p>-view-dag-combine2-dags displays the DAG before the second optimization
pass.</p>
<p>-view-isel-dags displays the DAG before the Select phase.</p>
<p class="last">-view-sched-dags displays the DAG before Scheduling.</p>
</div>
<p>By tracking <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt>, you can see the DAG translation steps as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>Initial selection DAG
Optimized lowered selection DAG
Type-legalized selection DAG
Optimized <span class="nb">type</span>-legalized selection DAG
Legalized selection DAG
Optimized legalized selection DAG
Instruction selection
Selected selection DAG
Scheduling
...
</pre></div>
</div>
<p>Let&#8217;s run <tt class="docutils literal"><span class="pre">llc</span></tt> with option -view-dag-combine1-dags, and open the output
result with Graphviz as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-12-177:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -view-dag-combine1-dags -march<span class="o">=</span>cpu0
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch4_2.bc -o ch4_2.cpu0.s
Writing <span class="s1">&#39;/tmp/llvm_84ibpm/dag.main.dot&#39;</span>...  <span class="k">done</span>.
118-165-12-177:InputFiles Jonathan<span class="nv">$ </span>Graphviz /tmp/llvm_84ibpm/dag.main.dot
</pre></div>
</div>
<p>It will show the /tmp/llvm_84ibpm/dag.main.dot as <a class="pageref" href="#otherinst-f1">Figure  1</a>.</p>
<div class="figure align-center" id="otherinst-f1">
<a class="reference internal image-reference" href="_images/17.png"><img alt="_images/17.png" src="_images/17.png" style="width: 687.0px; height: 851.0px;" /></a>
<p class="caption">Figure 1: llc option -view-dag-combine1-dags graphic view</p>
</div>
<p>From <a class="pageref" href="#otherinst-f1">Figure  1</a>, we can see the -view-dag-combine1-dags option is for
Initial selection DAG.
We list the other view options and their corresponding DAG translation stage as
follows,</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><tt class="docutils literal"><span class="pre">llc</span></tt> Graphviz options and corresponding DAG translation stage</p>
<p>-view-dag-combine1-dags: Initial selection DAG</p>
<p>-view-legalize-dags: Optimized type-legalized selection DAG</p>
<p>-view-dag-combine2-dags: Legalized selection DAG</p>
<p>-view-isel-dags: Optimized legalized selection DAG</p>
<p class="last">-view-sched-dags: Selected selection DAG</p>
</div>
<p>The -view-isel-dags is important and often used by an llvm backend writer
because it is the DAG before instruction selection.
The backend programmer need to know what is the DAG for writing the pattern
match instruction in target description file .td.</p>
</div>
<div class="section" id="local-variable-pointer">
<h2>Local variable pointer<a class="headerlink" href="#local-variable-pointer" title="Permalink to this headline">¶</a></h2>
<p>To support pointer to local variable, add this code fragment in
Cpu0InstrInfo.td and Cpu0InstPrinter.cpp as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_4/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def mem_ea : Operand&lt;i32&gt; {
let PrintMethod = "printMemOperandEA";
let MIOperandInfo = (ops CPURegs, simm16);
let EncoderMethod = "getMemEncoding";
}
...
class EffectiveAddress&lt;string instr_asm, RegisterClass RC, Operand Mem&gt; :
FMem&lt;0x09, (outs RC:$ra), (ins Mem:$addr),
   instr_asm, [(set RC:$ra, addr:$addr)], IIAlu&gt;;
...
// FrameIndexes are legalized when they are operands from load/store
// instructions. The same not happens for stack address copies, so an
// add op with mem ComplexPattern is used and the stack address copy
// can be matched. It's similar to Sparc LEA_ADDRi
def LEA_ADDiu : EffectiveAddress&lt;"addiu\t$ra, $addr", CPURegs, mem_ea&gt; {
let isCodeGenOnly = 1;
}</pre>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_4/Cpu0InstPrinter.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span>
<span class="n">printMemOperandEA</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// when using stack locations for not load/store instructions</span>
<span class="c1">// print the same way as all normal 3 operand instructions.</span>
<span class="n">printOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
<span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>
<span class="n">printOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">opNum</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Run ch4_4.cpp with code Chapter4_4/ which support pointer to local variable,
will get result as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch4_4.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>

  <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>clang -c ch4_4.cpp -emit-llvm -o ch4_4.bc
118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_
debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_4.bc -o ch4_4.cpu0.s
118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>cat ch4_4.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch4_5.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main            <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,16,<span class="nv">$lr</span>
  .mask 0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 16
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$sp</span>, 8
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
</div>
<div class="section" id="operator-mod">
<h2>Operator mod, %<a class="headerlink" href="#operator-mod" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-dag-of">
<h3>The DAG of %<a class="headerlink" href="#the-dag-of" title="Permalink to this headline">¶</a></h3>
<p>Example input code ch4_5.cpp which contains the C operator <strong>“%”</strong> and it&#8217;s
corresponding llvm IR, as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch4_5.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
<span class="c1">//  unsigned int b = 11;</span>
  
  <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">12</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-bash"><div class="highlight"><pre>; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch4_5.bc&#39;</span>
 target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-</span>
<span class="s2"> f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128-n8:16:32-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;i386-apple-macosx10.8.0&quot;</span>

define i32 @main<span class="o">()</span> nounwind ssp <span class="o">{</span>
entry:
%retval <span class="o">=</span> alloca i32, align 4
%b <span class="o">=</span> alloca i32, align 4
store i32 0, i32* %retval
store i32 11, i32* %b, align 4
%0 <span class="o">=</span> load i32* %b, align 4
%add <span class="o">=</span> add nsw i32 %0, 1
%rem <span class="o">=</span> srem i32 %add, 12
store i32 %rem, i32* %b, align 4
%1 <span class="o">=</span> load i32* %b, align 4
ret i32 %1
<span class="o">}</span>
</pre></div>
</div>
<p>LLVM <strong>srem</strong> is the IR corresponding <strong>“%”</strong>, reference sub-section
&#8220;srem instruction&#8221; of <a class="footnote-reference" href="#id10" id="id5">[3]</a>.
Copy the reference as follows,</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>&#8216;srem&#8217;</strong> Instruction</p>
<p>Syntax:
<strong>&lt;result&gt; = srem &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields {ty}:result</strong></p>
<p>Overview:
The <strong>&#8216;srem&#8217;</strong> instruction returns the remainder from the signed division of its
two operands. This instruction can also take vector versions of the values in
which case the elements must be integers.</p>
<p>Arguments:
The two arguments to the <strong>&#8216;srem&#8217;</strong> instruction must be integer or vector of
integer values. Both arguments must have identical types.</p>
<p>Semantics:
This instruction returns the remainder of a division (where the result is
either zero or has the same sign as the dividend, op1), not the modulo operator
(where the result is either zero or has the same sign as the divisor, op2) of
a value. For more information about the difference, see The Math Forum. For a
table of how this is implemented in various languages, please see Wikipedia:
modulo operation.</p>
<p>Note that signed integer remainder and unsigned integer remainder are distinct
operations; for unsigned integer remainder, use <strong>&#8216;urem&#8217;</strong>.</p>
<p>Taking the remainder of a division by zero leads to undefined behavior.
Overflow also leads to undefined behavior; this is a rare case, but can occur,
for example, by taking the remainder of a 32-bit division of -2147483648 by -1.
(The remainder doesn&#8217;t actually overflow, but this rule lets srem be
implemented using instructions that return both the result of the division and
the remainder.)</p>
<p class="last">Example:
&lt;result&gt; = <strong>srem i32 4, %var</strong>      ; yields {i32}:result = 4 % %var</p>
</div>
<p>Run Chapter4_5/ with input file ch4_5.bc via <tt class="docutils literal"><span class="pre">llc</span></tt> option –view-isel-dags as
below, will get the following error message and the llvm DAG of
<a class="pageref" href="#otherinst-f2">Figure  2</a> below.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-37:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -view-isel-dags -relocation-model<span class="o">=</span>
pic -filetype<span class="o">=</span>asm ch4_5.bc -o ch4_5.cpu0.s
...
LLVM ERROR: Cannot <span class="k">select</span>: 0x7fa73a02ea10: <span class="nv">i32</span> <span class="o">=</span> mulhs 0x7fa73a02c610,
0x7fa73a02e910 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>12<span class="o">]</span>
0x7fa73a02c610: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>
0x7fa73a02e910: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;715827883&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>9<span class="o">]</span>
</pre></div>
</div>
<div class="figure align-center" id="otherinst-f2">
<a class="reference internal image-reference" href="_images/26.png"><img alt="_images/26.png" src="_images/26.png" style="width: 580.0px; height: 629.0px;" /></a>
<p class="caption">Figure 2: ch4_5.bc DAG</p>
</div>
<p>LLVM replace srem divide operation with multiply operation in DAG optimization
because DIV operation cost more in time than MUL.
For example code <strong>“int b = 11; b=(b+1)%12;”</strong>, it translate into
<a class="pageref" href="#otherinst-f2">Figure  2</a>.
We verify the result and explain it by calculate the value in each node.
The 0xC*0x2AAAAAAB=0x2,00000004, (mulhs 0xC, 0x2AAAAAAAB) meaning get the Signed
mul high word (32bits).
Multiply with 2 operands of 1 word size generate the 2 word size of result
(0x2, 0xAAAAAAAB).
The high word result, in this case is 0x2.
The final result (sub 12, 12) is 0 which match the statement (11+1)%12.</p>
</div>
<div class="section" id="arm-solution">
<h3>Arm solution<a class="headerlink" href="#arm-solution" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s run Chapter4_5_1/ with ch4_5.cpp as well as <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-view-sched-dags</span></tt> option
to get <a class="pageref" href="#otherinst-f3">Figure  3</a>.
Similarly, SMMUL get the high word of multiply result.</p>
<div class="figure align-center" id="otherinst-f3">
<a class="reference internal image-reference" href="_images/35.png"><img alt="_images/35.png" src="_images/35.png" style="width: 687.0px; height: 702.0px;" /></a>
<p class="caption">Figure 3: Translate ch4_5.bc into cpu0 backend DAG</p>
</div>
<p>Follows is the result of run Chapter4_5_1/ with ch4_5.bc.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_
debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_5.bc -o ch4_5.cpu0.s
118-165-71-252:InputFiles Jonathan<span class="nv">$ </span>cat ch4_5.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch4_5.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 11
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 10922
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 16
  ori <span class="nv">$3</span>, <span class="nv">$2</span>, 43691
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 12
  smmul <span class="nv">$3</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  shr <span class="nv">$4</span>, <span class="nv">$3</span>, 31
  sra <span class="nv">$3</span>, <span class="nv">$3</span>, 1
  addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  mul <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  sub <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>The other instruction UMMUL and llvm IR mulhu are unsigned int type for
operator %.
You can check it by unmark the <strong>“unsigned int b = 11;”</strong> in ch4_5.cpp.</p>
<p>Use SMMUL instruction to get the high word of multiplication result is adopted
in ARM.
The Chapter4_5_1/ use the ARM solution.
With this solution, the following code is needed.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_5_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Transformation Function - get the lower 16 bits.
def LO16 : SDNodeXForm&lt;imm, [{
return getImm(N, N-&gt;getZExtValue() &amp; 0xFFFF);
}]&gt;;

// Transformation Function - get the higher 16 bits.
def HI16 : SDNodeXForm&lt;imm, [{
return getImm(N, (N-&gt;getZExtValue() &gt;&gt; 16) &amp; 0xFFFF);
}]&gt;;
...
def SMMUL   : ArithLogicR&lt;0x50, "smmul", mulhs, IIImul, CPURegs, 1&gt;;
def UMMUL   : ArithLogicR&lt;0x51, "ummul", mulhu, IIImul, CPURegs, 1&gt;;
...
// Arbitrary immediates
def : Pat&lt;(i32 imm:$imm),
  (OR (SHL (ADDiu ZERO, (HI16 imm:$imm)), 16), (ADDiu ZERO, (LO16 imm:$imm)))&gt;;</pre>
</div>
</div>
<div class="section" id="mips-solution">
<h3>Mips solution<a class="headerlink" href="#mips-solution" title="Permalink to this headline">¶</a></h3>
<p>Mips use MULT instruction and save the high &amp; low part to register HI and LO.
After that, use mfhi/mflo to move register HI/LO to your general purpose
register.
ARM SMMUL is fast if you only need the HI part of result (it ignore the LO part
of operation). ARM also provide SMULL (signed multiply long) to get the whole
64 bits result.
If you need the LO part of result, you can use Cpu0 MUL instruction which only
get the LO part of result.
Chapter4_5_2/ is implemented with Mips MULT style.
We choose it as the implementation of this book to add instructions as less as
possible. This approach is better for Cpu0 to keep it as a tutorial architecture
for school teaching purpose material, and apply Cpu0 as an engineer learning
materials in compiler, system program and verilog CPU hardware design.
For Mips style implementation, we add the following code in
Cpu0RegisterInfo.td, Cpu0InstrInfo.td and Cpu0ISelDAGToDAG.cpp.
And list the related DAG nodes mulhs and mulhu which are used in Chapter4_5_2/
from TargetSelectionDAG.td.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_5_2/Cpu0RegisterInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Hi/Lo registers</span>
<span class="n">def</span> <span class="n">HI</span>  <span class="o">:</span> <span class="n">Register</span><span class="o">&lt;</span><span class="s">&quot;HI&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">LO</span>  <span class="o">:</span> <span class="n">Register</span><span class="o">&lt;</span><span class="s">&quot;LO&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// Hi/Lo Registers</span>
<span class="n">def</span> <span class="n">HILO</span> <span class="o">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> <span class="n">HI</span><span class="p">,</span> <span class="n">LO</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Cpu0Schedule.td</span>
<span class="p">...</span>
<span class="n">def</span> <span class="n">IIHiLo</span>       <span class="o">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">def</span> <span class="n">Cpu0GenericItineraries</span> <span class="o">:</span> <span class="n">ProcessorItineraries</span><span class="o">&lt;</span><span class="p">[</span><span class="n">ALU</span><span class="p">,</span> <span class="n">IMULDIV</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span>
<span class="p">...</span>
<span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIHiLo</span>       <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="p">[</span><span class="n">IMULDIV</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">...</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_5_2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Mul, Div
class Mult&lt;bits&lt;8&gt; op, string instr_asm, InstrItinClass itin,
     RegisterClass RC, list&lt;Register&gt; DefRegs&gt;:
FL&lt;op, (outs), (ins RC:$ra, RC:$rb),
  !strconcat(instr_asm, "\t$ra, $rb"), [], itin&gt; {
let imm16 = 0;
let isCommutable = 1;
let Defs = DefRegs;
let neverHasSideEffects = 1;
}

class Mult32&lt;bits&lt;8&gt; op, string instr_asm, InstrItinClass itin&gt;:
Mult&lt;op, instr_asm, itin, CPURegs, [HI, LO]&gt;;

// Move from Hi/Lo
class MoveFromLOHI&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC,
         list&lt;Register&gt; UseRegs&gt;:
FL&lt;op, (outs RC:$ra), (ins),
   !strconcat(instr_asm, "\t$ra"), [], IIHiLo&gt; {
let rb = 0;
let imm16 = 0;
let Uses = UseRegs;
let neverHasSideEffects = 1;
}
...
def MULT    : Mult32&lt;0x50, "mult", IIImul&gt;;
def MULTu   : Mult32&lt;0x51, "multu", IIImul&gt;;

def MFHI : MoveFromLOHI&lt;0x40, "mfhi", CPURegs, [HI]&gt;;
def MFLO : MoveFromLOHI&lt;0x41, "mflo", CPURegs, [LO]&gt;;</pre>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_5_2/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// Select multiply instructions.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">SDNode</span><span class="o">*</span><span class="p">,</span> <span class="n">SDNode</span><span class="o">*&gt;</span>
<span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span><span class="n">SelectMULT</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Opc</span><span class="p">,</span> <span class="n">DebugLoc</span> <span class="n">dl</span><span class="p">,</span> <span class="n">EVT</span> <span class="n">Ty</span><span class="p">,</span>
              <span class="kt">bool</span> <span class="n">HasLo</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">HasHi</span><span class="p">)</span> <span class="p">{</span>
<span class="n">SDNode</span> <span class="o">*</span><span class="n">Lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">Hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">SDNode</span> <span class="o">*</span><span class="n">Mul</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Opc</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Glue</span><span class="p">,</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">SDValue</span> <span class="n">InFlag</span> <span class="o">=</span> <span class="n">SDValue</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">HasLo</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Lo</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">MFLO</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span>
                <span class="n">Ty</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Glue</span><span class="p">,</span> <span class="n">InFlag</span><span class="p">);</span>
  <span class="n">InFlag</span> <span class="o">=</span> <span class="n">SDValue</span><span class="p">(</span><span class="n">Lo</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">HasHi</span><span class="p">)</span>
  <span class="n">Hi</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">MFHI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span>
                <span class="n">Ty</span><span class="p">,</span> <span class="n">InFlag</span><span class="p">);</span>

<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">Lo</span><span class="p">,</span> <span class="n">Hi</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// Select instructions not customized! Used for</span>
<span class="c1">/// expanded, promoted and normal instructions</span>
<span class="n">SDNode</span><span class="o">*</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span><span class="n">Select</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">unsigned</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>
<span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">EVT</span> <span class="n">NodeTy</span> <span class="o">=</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">getValueType</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">MultOpc</span><span class="p">;</span>
<span class="k">switch</span><span class="p">(</span><span class="n">Opcode</span><span class="p">)</span> <span class="p">{</span>
<span class="k">default</span><span class="o">:</span> <span class="k">break</span><span class="p">;</span>

<span class="k">case</span> <span class="n">ISD</span><span class="o">::</span><span class="nl">MULHS:</span>
<span class="k">case</span> <span class="n">ISD</span><span class="o">::</span><span class="nl">MULHU:</span> <span class="p">{</span>
  <span class="n">MultOpc</span> <span class="o">=</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">ISD</span><span class="o">::</span><span class="n">MULHU</span> <span class="o">?</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MULTu</span> <span class="o">:</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MULT</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">SelectMULT</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">MultOpc</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">NodeTy</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">).</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">include/llvm/Target/TargetSelectionDAG.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">mulhs</span>    <span class="o">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s">&quot;ISD::MULHS&quot;</span>     <span class="p">,</span> <span class="n">SDTIntBinOp</span><span class="p">,</span> <span class="p">[</span><span class="n">SDNPCommutative</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">mulhu</span>    <span class="o">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s">&quot;ISD::MULHU&quot;</span>     <span class="p">,</span> <span class="n">SDTIntBinOp</span><span class="p">,</span> <span class="p">[</span><span class="n">SDNPCommutative</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Except the custom type, llvm IR operations of expand and promote type will call
Cpu0DAGToDAGISel::Select() during instruction selection of DAG translation.
In Select(), it return the HI part of multiplication result to HI register,
for IR operations of mulhs or mulhu.
After that, MFHI instruction move the HI register to cpu0 field &#8220;a&#8221; register,
$ra.
MFHI instruction is FL format and only use cpu0 field &#8220;a&#8221; register, we set
the $rb and imm16 to 0.
<a class="pageref" href="#otherinst-f4">Figure  4</a> and ch4_5.cpu0.s are the result of compile ch4_5.bc.</p>
<div class="figure align-center" id="otherinst-f4">
<a class="reference internal image-reference" href="_images/44.png"><img alt="_images/44.png" src="_images/44.png" style="width: 231.75px; height: 605.25px;" /></a>
<p class="caption">Figure 4: DAG for ch4_5.bc with Mips style MULT</p>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>cat ch4_5.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch4_5.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 11
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 10922
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 16
  ori <span class="nv">$3</span>, <span class="nv">$2</span>, 43691
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 12
  mult  <span class="nv">$2</span>, <span class="nv">$3</span>
  mfhi  <span class="nv">$3</span>
  shr <span class="nv">$4</span>, <span class="nv">$3</span>, 31
  sra <span class="nv">$3</span>, <span class="nv">$3</span>, 1
  addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  mul <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  sub <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
</div>
</div>
<div class="section" id="full-support">
<h2>Full support %<a class="headerlink" href="#full-support" title="Permalink to this headline">¶</a></h2>
<p>The sensitive readers may find the llvm using <strong>“multiplication”</strong> instead
of <strong>“div”</strong> to get the <strong>“%”</strong> result just because our example use constant as
divider, <strong>“(b+1)%12”</strong> in our example.
If programmer use variable as the divider like <strong>“(b+1)%a”</strong>, then what will
happen in our code.
The answer is our code will has error to take care this.
In <a class="reference external" href="http://jonathan2251.github.com/lbd/otherinst.html#support-arithmetic-instructions">section Support arithmetic instructions</a>, we use <strong>“div a, b”</strong>
to hold the quotient part in register.
The multiplication operator <strong>“*”</strong> need 64 bits of register to hold the result
for two 32 bits of operands multiplication.
We modify cpu0 to use the pair of registers LO and HI which just like Mips to
solve this issue in last section.
Now, it&#8217;s time to modify cpu0 for integer <strong>“divide”</strong> operator again.
We use LO and HI registers to hold the <strong>&#8220;quotient&#8221;</strong> and <strong>&#8220;remainder&#8221;</strong> and
use instructions <strong>“mflo”</strong> and <strong>“mfhi”</strong> to get the result from LO or HI
registers.
With this solution, the <strong>“c = a / b”</strong> can be got by <strong>“div a, b”</strong> and
<strong>“mflo c”</strong>; the <strong>“c = a % b”</strong> can be got by <strong>“div a, b”</strong> and <strong>“mfhi c”</strong>.</p>
<p>Chapter4_6/ support operator <strong>“%”</strong> and <strong>“/”</strong>.
The code added in Chapter4_6/ as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_6/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0InstrInfo</span><span class="o">::</span>
<span class="n">copyPhysReg</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
            <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span> <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">,</span>
            <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span>
            <span class="kt">bool</span> <span class="n">KillSrc</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ZeroReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">DestReg</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Copy to CPU Reg.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">))</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">ZeroReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">HI</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MFHI</span><span class="p">,</span> <span class="n">SrcReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LO</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MFLO</span><span class="p">,</span> <span class="n">SrcReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Copy from CPU Reg.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">HI</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MTHI</span><span class="p">,</span> <span class="n">DestReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LO</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MTLO</span><span class="p">,</span> <span class="n">DestReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">Opc</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Cannot copy registers&quot;</span><span class="p">);</span>

  <span class="n">MachineInstrBuilder</span> <span class="n">MIB</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Opc</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">DestReg</span><span class="p">,</span> <span class="n">RegState</span><span class="o">::</span><span class="n">Define</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ZeroReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZeroReg</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">,</span> <span class="n">getKillRegState</span><span class="p">(</span><span class="n">KillSrc</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_6/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">copyPhysReg</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                           <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span> <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">,</span>
                           <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span>
                           <span class="kt">bool</span> <span class="n">KillSrc</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_6/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def SDT_Cpu0DivRem     : SDTypeProfile&lt;0, 2,
           [SDTCisInt&lt;0&gt;,
          SDTCisSameAs&lt;0, 1&gt;]&gt;;
...
// DivRem(u) nodes
def Cpu0DivRem  : SDNode&lt;"Cpu0ISD::DivRem", SDT_Cpu0DivRem,
       [SDNPOutGlue]&gt;;
def Cpu0DivRemU : SDNode&lt;"Cpu0ISD::DivRemU", SDT_Cpu0DivRem,
       [SDNPOutGlue]&gt;;
...
class Div&lt;SDNode opNode, bits&lt;8&gt; op, string instr_asm, InstrItinClass itin,
  RegisterClass RC, list&lt;Register&gt; DefRegs&gt;:
FL&lt;op, (outs), (ins RC:$rb, RC:$rc),
 !strconcat(instr_asm, "\t$$zero, $rb, $rc"),
 [(opNode RC:$rb, RC:$rc)], itin&gt; {
let imm16 = 0;
let Defs = DefRegs;
}

class Div32&lt;SDNode opNode, bits&lt;8&gt; op, string instr_asm, InstrItinClass itin&gt;:
Div&lt;opNode, op, instr_asm, itin, CPURegs, [HI, LO]&gt;;
...
class MoveToLOHI&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC,
     list&lt;Register&gt; DefRegs&gt;:
FL&lt;op, (outs), (ins RC:$ra),
 !strconcat(instr_asm, "\t$ra"), [], IIHiLo&gt; {
let rb = 0;
let imm16 = 0;
let Defs = DefRegs;
let neverHasSideEffects = 1;
}
...
def SDIV    : Div32&lt;Cpu0DivRem, 0x16, "div", IIIdiv&gt;;
def UDIV    : Div32&lt;Cpu0DivRemU, 0x17, "divu", IIIdiv&gt;;
...
def MTHI : MoveToLOHI&lt;0x42, "mthi", CPURegs, [HI]&gt;;
def MTLO : MoveToLOHI&lt;0x43, "mtlo", CPURegs, [LO]&gt;;</pre>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_6/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span>
<span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="k">new</span> <span class="n">TargetLoweringObjectFileELF</span><span class="p">()),</span>
<span class="n">Subtarget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
<span class="p">...</span>
<span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SDIV</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
<span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SREM</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
<span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">UDIV</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
<span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">UREM</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>

<span class="n">setTargetDAGCombine</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SDIVREM</span><span class="p">);</span>
<span class="n">setTargetDAGCombine</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">UDIVREM</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">static</span> <span class="n">SDValue</span> <span class="n">PerformDivRemCombine</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">SelectionDAG</span><span class="o">&amp;</span> <span class="n">DAG</span><span class="p">,</span>
        <span class="n">TargetLowering</span><span class="o">::</span><span class="n">DAGCombinerInfo</span> <span class="o">&amp;</span><span class="n">DCI</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">Cpu0Subtarget</span><span class="o">*</span> <span class="n">Subtarget</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">DCI</span><span class="p">.</span><span class="n">isBeforeLegalizeOps</span><span class="p">())</span>
<span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>

<span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getValueType</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">LO</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LO</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="n">HI</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">HI</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="n">opc</span> <span class="o">=</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">ISD</span><span class="o">::</span><span class="n">SDIVREM</span> <span class="o">?</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">DivRem</span> <span class="o">:</span>
            <span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">DivRemU</span><span class="p">;</span>
<span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>

<span class="n">SDValue</span> <span class="n">DivRem</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">opc</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Glue</span><span class="p">,</span>
         <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">SDValue</span> <span class="n">InChain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">();</span>
<span class="n">SDValue</span> <span class="n">InGlue</span> <span class="o">=</span> <span class="n">DivRem</span><span class="p">;</span>

<span class="c1">// insert MFLO</span>
<span class="k">if</span> <span class="p">(</span><span class="n">N</span><span class="o">-&gt;</span><span class="n">hasAnyUseOfValue</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
<span class="n">SDValue</span> <span class="n">CopyFromLo</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">InChain</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">LO</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span>
          <span class="n">InGlue</span><span class="p">);</span>
<span class="n">DAG</span><span class="p">.</span><span class="n">ReplaceAllUsesOfValueWith</span><span class="p">(</span><span class="n">SDValue</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">CopyFromLo</span><span class="p">);</span>
<span class="n">InChain</span> <span class="o">=</span> <span class="n">CopyFromLo</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">InGlue</span> <span class="o">=</span> <span class="n">CopyFromLo</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// insert MFHI</span>
<span class="k">if</span> <span class="p">(</span><span class="n">N</span><span class="o">-&gt;</span><span class="n">hasAnyUseOfValue</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
<span class="n">SDValue</span> <span class="n">CopyFromHi</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">InChain</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span>
          <span class="n">HI</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">InGlue</span><span class="p">);</span>
<span class="n">DAG</span><span class="p">.</span><span class="n">ReplaceAllUsesOfValueWith</span><span class="p">(</span><span class="n">SDValue</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">CopyFromHi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">PerformDAGCombine</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">DAGCombinerInfo</span> <span class="o">&amp;</span><span class="n">DCI</span><span class="p">)</span>
<span class="k">const</span> <span class="p">{</span>
<span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span> <span class="o">=</span> <span class="n">DCI</span><span class="p">.</span><span class="n">DAG</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="n">opc</span> <span class="o">=</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>

<span class="k">switch</span> <span class="p">(</span><span class="n">opc</span><span class="p">)</span> <span class="p">{</span>
<span class="k">default</span><span class="o">:</span> <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">ISD</span><span class="o">::</span><span class="nl">SDIVREM:</span>
<span class="k">case</span> <span class="n">ISD</span><span class="o">::</span><span class="nl">UDIVREM:</span>
<span class="k">return</span> <span class="n">PerformDivRemCombine</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">DCI</span><span class="p">,</span> <span class="n">Subtarget</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter4_6/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Cpu0ISD</span> <span class="p">{</span>
<span class="k">enum</span> <span class="n">NodeType</span> <span class="p">{</span>
  <span class="c1">// Start the numbering from where ISD NodeType finishes.</span>
  <span class="n">FIRST_NUMBER</span> <span class="o">=</span> <span class="n">ISD</span><span class="o">::</span><span class="n">BUILTIN_OP_END</span><span class="p">,</span>
  <span class="n">Ret</span><span class="p">,</span>
  <span class="c1">// DivRem(u)</span>
  <span class="n">DivRem</span><span class="p">,</span>
  <span class="n">DivRemU</span>
<span class="p">};</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Run with ch4_6_2.cpp can get the result for operator <strong>“/”</strong> as below.
But run with ch4_6_1.cpp as below, cannot get the <strong>“div”</strong> for operator
<strong>“%”</strong>.
It still use <strong>&#8220;multiplication&#8221;</strong> instead of <strong>&#8220;div&#8221;</strong> because llvm do
<strong>“Constant Propagation Optimization”</strong> on this.
The ch4_6_2.cpp can get the <strong>“div”</strong> for <strong>“%”</strong> result since it make the
llvm <strong>“Constant Propagation Optimization”</strong> useless in this.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch4_6_1.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

  <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">a</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch4_6_2.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">test_mod</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
  
  <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">c</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-77-79:InputFiles Jonathan<span class="nv">$ </span>clang -c ch4_6_2.cpp -emit-llvm -o ch4_6_2.bc
118-165-77-79:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_
debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_6_2.bc -o -
...
div <span class="nv">$zero</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
mflo  <span class="nv">$2</span>
...
</pre></div>
</div>
<p>To explain how Chapter4_6 work with <strong>“div”</strong>, let&#8217;s run Chapter8_8 with
ch4_6_2.cpp as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-83-58:InputFiles Jonathan<span class="nv">$ </span>clang -c ch4_6_2.cpp -I/Applications/Xcode.app/
Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.8.sdk/usr/
include/ -emit-llvm -o ch4_6_2.bc
118-165-83-58:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/bin/
Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch4_6_2.bc -o -
Args: /Users/Jonathan/llvm/test/cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch4_6_2.bc -o -

<span class="o">===</span> _Z8test_modi
Initial selection DAG: BB#0 <span class="s1">&#39;_Z8test_modi:&#39;</span>
SelectionDAG has 21 nodes:
  0x7fed68410bc8: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882cb10: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882cd10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882ce10: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt;

  0x7fed6882d110: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

      0x7fed68410bc8: &lt;multiple use&gt;
        0x7fed68410bc8: &lt;multiple use&gt;
        0x7fed6882ca10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;-1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

        0x7fed6882cb10: &lt;multiple use&gt;
      0x7fed6882cc10: i32,ch <span class="o">=</span> load 0x7fed68410bc8, 0x7fed6882ca10,
      0x7fed6882cb10&lt;LD4<span class="o">[</span>FixedStack-1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7fed6882cd10: &lt;multiple use&gt;
      0x7fed6882cb10: &lt;multiple use&gt;
    0x7fed6882cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed68410bc8, 0x7fed6882cc10, 0x7fed6882cd10,
    0x7fed6882cb10&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

    0x7fed6882d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;11&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

    0x7fed6882d110: &lt;multiple use&gt;
    0x7fed6882cb10: &lt;multiple use&gt;
  0x7fed6882d210: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed6882cf10, 0x7fed6882d010, 0x7fed6882d110,
  0x7fed6882cb10&lt;ST4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

    0x7fed6882d210: &lt;multiple use&gt;
    0x7fed6882d110: &lt;multiple use&gt;
    0x7fed6882cb10: &lt;multiple use&gt;
  0x7fed6882d310: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882d110,
  0x7fed6882cb10&lt;LD4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span>

    0x7fed6882d210: &lt;multiple use&gt;
    0x7fed6882cd10: &lt;multiple use&gt;
    0x7fed6882cb10: &lt;multiple use&gt;
  0x7fed6882d610: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882cd10,
  0x7fed6882cb10&lt;LD4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

      0x7fed6882d310: &lt;multiple use&gt;
      0x7fed6882d610: &lt;multiple use&gt;
    0x7fed6882d810: <span class="nv">ch</span> <span class="o">=</span> TokenFactor 0x7fed6882d310:1, 0x7fed6882d610:1 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>

        0x7fed6882d310: &lt;multiple use&gt;
        0x7fed6882d410: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>4<span class="o">]</span>

      0x7fed6882d510: <span class="nv">i32</span> <span class="o">=</span> add 0x7fed6882d310, 0x7fed6882d410 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>4<span class="o">]</span>

      0x7fed6882d610: &lt;multiple use&gt;
    0x7fed6882d710: <span class="nv">i32</span> <span class="o">=</span> srem 0x7fed6882d510, 0x7fed6882d610 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

    0x7fed6882d110: &lt;multiple use&gt;
    0x7fed6882cb10: &lt;multiple use&gt;
  0x7fed6882fc10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed6882d810, 0x7fed6882d710, 0x7fed6882d110,
  0x7fed6882cb10&lt;ST4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>

  0x7fed6882fe10: <span class="nv">i32</span> <span class="o">=</span> Register %V0

    0x7fed6882fc10: &lt;multiple use&gt;
    0x7fed6882fe10: &lt;multiple use&gt;
      0x7fed6882fc10: &lt;multiple use&gt;
      0x7fed6882d110: &lt;multiple use&gt;
      0x7fed6882cb10: &lt;multiple use&gt;
    0x7fed6882fd10: i32,ch <span class="o">=</span> load 0x7fed6882fc10, 0x7fed6882d110,
    0x7fed6882cb10&lt;LD4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>8<span class="o">]</span>

  0x7fed6882ff10: ch,glue <span class="o">=</span> CopyToReg 0x7fed6882fc10, 0x7fed6882fe10,
  0x7fed6882fd10

    0x7fed6882ff10: &lt;multiple use&gt;
    0x7fed6882fe10: &lt;multiple use&gt;
    0x7fed6882ff10: &lt;multiple use&gt;
  0x7fed68830010: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x7fed6882ff10, 0x7fed6882fe10,
  0x7fed6882ff10:1

Replacing.1 0x7fed6882fd10: i32,ch <span class="o">=</span> load 0x7fed6882fc10, 0x7fed6882d110,
0x7fed6882cb10&lt;LD4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>8<span class="o">]</span>

With: 0x7fed6882d710: <span class="nv">i32</span> <span class="o">=</span> srem 0x7fed6882d510, 0x7fed6882d610 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>
 and 1 other values

Replacing.1 0x7fed6882d310: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882d110,
0x7fed6882cb10&lt;LD4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span>

With: 0x7fed6882d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;11&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>
 and 1 other values

Replacing.3 0x7fed6882d810: <span class="nv">ch</span> <span class="o">=</span> TokenFactor 0x7fed6882d210,
0x7fed6882d610:1 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>

With: 0x7fed6882d610: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882cd10,
0x7fed6882cb10&lt;LD4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>


Replacing.3 0x7fed6882d510: <span class="nv">i32</span> <span class="o">=</span> add 0x7fed6882d010, 0x7fed6882d410 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>4<span class="o">]</span>

With: 0x7fed6882d810: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt;


Replacing.1 0x7fed6882cc10: i32,ch <span class="o">=</span> load 0x7fed68410bc8, 0x7fed6882ca10,
0x7fed6882cb10&lt;LD4<span class="o">[</span>FixedStack-1<span class="o">](</span><span class="nv">align</span><span class="o">=</span>8<span class="o">)</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

With: 0x7fed6882cc10: i32,ch <span class="o">=</span> load 0x7fed68410bc8, 0x7fed6882ca10,
0x7fed6882cb10&lt;LD4<span class="o">[</span>FixedStack-1<span class="o">](</span><span class="nv">align</span><span class="o">=</span>8<span class="o">)</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>
 and 1 other values
Optimized lowered selection DAG: BB#0 <span class="s1">&#39;_Z8test_modi:&#39;</span>
SelectionDAG has 16 nodes:
  0x7fed68410bc8: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882cb10: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882cd10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882d110: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

        0x7fed68410bc8: &lt;multiple use&gt;
          0x7fed68410bc8: &lt;multiple use&gt;
          0x7fed6882ca10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;-1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

          0x7fed6882cb10: &lt;multiple use&gt;
        0x7fed6882cc10: i32,ch <span class="o">=</span> load 0x7fed68410bc8, 0x7fed6882ca10,
        0x7fed6882cb10&lt;LD4<span class="o">[</span>FixedStack-1<span class="o">](</span><span class="nv">align</span><span class="o">=</span>8<span class="o">)</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

        0x7fed6882cd10: &lt;multiple use&gt;
        0x7fed6882cb10: &lt;multiple use&gt;
      0x7fed6882cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed68410bc8, 0x7fed6882cc10, 0x7fed6882cd10,
      0x7fed6882cb10&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7fed6882d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;11&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

      0x7fed6882d110: &lt;multiple use&gt;
      0x7fed6882cb10: &lt;multiple use&gt;
    0x7fed6882d210: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed6882cf10, 0x7fed6882d010, 0x7fed6882d110,
    0x7fed6882cb10&lt;ST4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

    0x7fed6882cd10: &lt;multiple use&gt;
    0x7fed6882cb10: &lt;multiple use&gt;
  0x7fed6882d610: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882cd10,
  0x7fed6882cb10&lt;LD4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

    0x7fed6882d810: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt;

    0x7fed6882d610: &lt;multiple use&gt;
  0x7fed6882d710: <span class="nv">i32</span> <span class="o">=</span> srem 0x7fed6882d810, 0x7fed6882d610 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

  0x7fed6882fe10: <span class="nv">i32</span> <span class="o">=</span> Register %V0

      0x7fed6882d610: &lt;multiple use&gt;
      0x7fed6882d710: &lt;multiple use&gt;
      0x7fed6882d110: &lt;multiple use&gt;
      0x7fed6882cb10: &lt;multiple use&gt;
    0x7fed6882fc10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed6882d610:1, 0x7fed6882d710, 0x7fed6882d110,
    0x7fed6882cb10&lt;ST4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>

    0x7fed6882fe10: &lt;multiple use&gt;
    0x7fed6882d710: &lt;multiple use&gt;
  0x7fed6882ff10: ch,glue <span class="o">=</span> CopyToReg 0x7fed6882fc10, 0x7fed6882fe10,
  0x7fed6882d710

    0x7fed6882ff10: &lt;multiple use&gt;
    0x7fed6882fe10: &lt;multiple use&gt;
    0x7fed6882ff10: &lt;multiple use&gt;
  0x7fed68830010: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x7fed6882ff10, 0x7fed6882fe10,
  0x7fed6882ff10:1

Type-legalized selection DAG: BB#0 <span class="s1">&#39;_Z8test_modi:&#39;</span>
SelectionDAG has 16 nodes:
  ...
  0x7fed6882d610: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882cd10,
  0x7fed6882cb10&lt;LD4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fed6882d810: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fed6882d610: &lt;multiple use&gt;
  0x7fed6882d710: <span class="nv">i32</span> <span class="o">=</span> srem 0x7fed6882d810, 0x7fed6882d610 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>
  ...

Legalized selection DAG: BB#0 <span class="s1">&#39;_Z8test_modi:&#39;</span>
SelectionDAG has 16 nodes:
  0x7fed68410bc8: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>0<span class="o">]</span>

  0x7fed6882cb10: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>2<span class="o">]</span>

  0x7fed6882cd10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>3<span class="o">]</span>

  0x7fed6882d110: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>

  0x7fed6882fe10: <span class="nv">i32</span> <span class="o">=</span> Register %V0 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>6<span class="o">]</span>
  ...
    0x7fed6882d810: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>

    0x7fed6882d610: &lt;multiple use&gt;
  0x7fed6882ce10: i32,i32 <span class="o">=</span> sdivrem 0x7fed6882d810, 0x7fed6882d610


Optimized legalized selection DAG: BB#0 <span class="s1">&#39;_Z8test_modi:&#39;</span>
SelectionDAG has 18 nodes:
  ...
    0x7fed6882d510: <span class="nv">i32</span> <span class="o">=</span> Register %HI

      0x7fed6882d810: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>

      0x7fed6882d610: &lt;multiple use&gt;
    0x7fed6882d410: <span class="nv">glue</span> <span class="o">=</span> Cpu0ISD::DivRem 0x7fed6882d810, 0x7fed6882d610

  0x7fed6882d310: i32,ch,glue <span class="o">=</span> CopyFromReg 0x7fed68410bc8, 0x7fed6882d510,
  0x7fed6882d410
  ...

<span class="o">=====</span> Instruction selection begins: BB#0 <span class="s1">&#39;&#39;</span>
...
Selecting: 0x7fed6882d410: <span class="nv">glue</span> <span class="o">=</span> Cpu0ISD::DivRem 0x7fed6882d810,
0x7fed6882d610 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>13<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x7fed6882d410: <span class="nv">glue</span> <span class="o">=</span>
Cpu0ISD::DivRem 0x7fed6882d810, 0x7fed6882d610 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>13<span class="o">]</span>

  Initial Opcode index to 1355
  Morphed node: 0x7fed6882d410: i32,glue <span class="o">=</span> SDIV 0x7fed6882d810, 0x7fed6882d610

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fed6882d410: i32,glue <span class="o">=</span> SDIV 0x7fed6882d810, 0x7fed6882d610
...
</pre></div>
</div>
<p>According above DAG translation message from <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt>, it do the
following things:</p>
<ol class="arabic simple">
<li>Reduce DAG nodes in stage &#8220;Optimized lowered selection DAG&#8221; (Replacing ...
displayed before &#8220;Optimized lowered selection DAG: BB#0 &#8216;_Z8test_modi:entry&#8217;
&#8221;).
Since SSA form has some redundant nodes for store and load, them can be
removed.</li>
<li>Change DAG srem to sdivrem in stage &#8220;Legalized selection DAG&#8221;.</li>
<li>Change DAG sdivrem to Cpu0ISD::DivRem and in stage &#8220;Optimized legalized
selection DAG&#8221;.</li>
<li>Add DAG &#8220;0x7fd25b830710: i32 = Register %HI&#8221; and &#8220;CopyFromReg 0x7fd25b410e18,
0x7fd25b830710, 0x7fd25b830910&#8221; in stage &#8220;Optimized legalized selection DAG&#8221;.</li>
</ol>
<p>Summary as Table: Stages for C operator % and Table: Functions handle the DAG
translation and pattern match for C operator %.</p>
<table border="1" class="docutils">
<caption>Stages for C operator %</caption>
<colgroup>
<col width="43%" />
<col width="26%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Stage</th>
<th class="head">IR/DAG/instruction</th>
<th class="head">IR/DAG/instruction</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>.bc</td>
<td>srem</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Legalized selection DAG</td>
<td>sdivrem</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Optimized legalized selection DAG</td>
<td>Cpu0ISD::DivRem</td>
<td>CopyFromReg xx, Hi, xx</td>
</tr>
<tr class="row-odd"><td>pattern match</td>
<td>div</td>
<td>mfhi</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<caption>Functions handle the DAG translation and pattern match for C operator %</caption>
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Translation</th>
<th class="head">Do by</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>srem =&gt; sdivrem</td>
<td>setOperationAction(ISD::SREM, MVT::i32, Expand);</td>
</tr>
<tr class="row-odd"><td>sdivrem =&gt; Cpu0ISD::DivRem</td>
<td>setTargetDAGCombine(ISD::SDIVREM);</td>
</tr>
<tr class="row-even"><td>sdivrem =&gt; CopyFromReg xx, Hi, xx</td>
<td>PerformDivRemCombine();</td>
</tr>
<tr class="row-odd"><td>Cpu0ISD::DivRem =&gt; div</td>
<td>SDIV (Cpu0InstrInfo.td)</td>
</tr>
<tr class="row-even"><td>CopyFromReg xx, Hi, xx =&gt; mfhi</td>
<td>MFLO (Cpu0InstrInfo.td)</td>
</tr>
</tbody>
</table>
<p>Item 2 as above, is triggered by code
&#8220;setOperationAction(ISD::SREM, MVT::i32, Expand);&#8221; in Cpu0ISelLowering.cpp.
About <strong>Expand</strong> please ref. <a class="footnote-reference" href="#id12" id="id6">[5]</a> and <a class="footnote-reference" href="#id13" id="id7">[6]</a>. Item 3 is triggered by code
&#8220;setTargetDAGCombine(ISD::SDIVREM);&#8221; in Cpu0ISelLowering.cpp.
Item 4 is did by PerformDivRemCombine() which called by PerformDAGCombine()
since the <strong>%</strong> corresponding <strong>srem</strong>
make the &#8220;N-&gt;hasAnyUseOfValue(1)&#8221; to true in PerformDivRemCombine().
Then, it create &#8220;CopyFromReg 0x7fd25b410e18, 0x7fd25b830710, 0x7fd25b830910&#8221;.
When use <strong>&#8220;/&#8221;</strong> in C, it will make &#8220;N-&gt;hasAnyUseOfValue(0)&#8221; to ture.
For sdivrem, <strong>sdiv</strong> make &#8220;N-&gt;hasAnyUseOfValue(0)&#8221; true while <strong>srem</strong> make
&#8220;N-&gt;hasAnyUseOfValue(1)&#8221; ture.</p>
<p>Above items will change the DAG when <tt class="docutils literal"><span class="pre">llc</span></tt> running. After that, the pattern
match defined in Chapter4_6/Cpu0InstrInfo.td will translate <strong>Cpu0ISD::DivRem</strong>
to <strong>div</strong>; and <strong>&#8220;CopyFromReg 0x7fd25b410e18, Register %H, 0x7fd25b830910&#8221;</strong>
to <strong>mfhi</strong>.</p>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>We support most of C operators in this chapter.
Until now, we have around 3400 lines of source code with comments.
With these 345 lines of source code added, it support the number of operators
from three to over ten.</p>
<p>List C operators, IR of .bc, Optimized legalized selection DAG and Cpu0
instructions implemented in this chapter in Table: Chapter 4 operators.</p>
<table border="1" class="docutils">
<caption>Chapter 4 operators</caption>
<colgroup>
<col width="10%" />
<col width="32%" />
<col width="35%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">C</th>
<th class="head">.bc</th>
<th class="head">Optimized legalized selection DAG</th>
<th class="head">Cpu0</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>+</td>
<td>add</td>
<td>add</td>
<td>add</td>
</tr>
<tr class="row-odd"><td>-</td>
<td>sub</td>
<td>sub</td>
<td>sub</td>
</tr>
<tr class="row-even"><td>*</td>
<td>mul</td>
<td>mul</td>
<td>mul</td>
</tr>
<tr class="row-odd"><td>/</td>
<td>sdiv</td>
<td>Cpu0ISD::DivRem</td>
<td>div</td>
</tr>
<tr class="row-even"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>udiv</td>
<td>Cpu0ISD::DivRemU</td>
<td>divu</td>
</tr>
<tr class="row-odd"><td>&amp;, &amp;&amp;</td>
<td>and</td>
<td>and</td>
<td>and</td>
</tr>
<tr class="row-even"><td>|, ||</td>
<td>or</td>
<td>or</td>
<td>or</td>
</tr>
<tr class="row-odd"><td>^</td>
<td>xor</td>
<td>xor</td>
<td>xor</td>
</tr>
<tr class="row-even"><td>&lt;&lt;</td>
<td>shl</td>
<td>shl</td>
<td>shl</td>
</tr>
<tr class="row-odd"><td>&gt;&gt;</td>
<td><ul class="first last simple">
<li>ashr</li>
<li>lshr</li>
</ul>
</td>
<td><ul class="first last simple">
<li>sra</li>
<li>srl</li>
</ul>
</td>
<td><ul class="first last simple">
<li>sra</li>
<li>shr</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>!</td>
<td><ul class="first last simple">
<li>%tobool = icmp ne i32 %0, 0</li>
<li>%lnot = xor i1 %tobool, true</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%lnot = (setcc %tobool, 0, seteq)</li>
<li>%conv = (and %lnot, 1)</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%1 = (xor %tobool, 0)</li>
<li>%true = (addiu $r0, 1)</li>
<li>%lnot = (xor %1, %true)</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li>%conv = zext i1 %lnot to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%conv = (and %lnot, 1)</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%conv = (and %lnot, 1)</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>%</td>
<td><ul class="first last simple">
<li>srem</li>
<li>sremu</li>
</ul>
</td>
<td><ul class="first last simple">
<li>Cpu0ISD::DivRem</li>
<li>Cpu0ISD::DivRemU</li>
</ul>
</td>
<td><ul class="first last simple">
<li>div</li>
<li>divu</li>
</ul>
</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html">http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://msdn.microsoft.com/en-us/library/336xbhcz%28v=vs.80%29.aspx">http://msdn.microsoft.com/en-us/library/336xbhcz%28v=vs.80%29.aspx</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">http://llvm.org/docs/CodeGenerator.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#expand">http://llvm.org/docs/WritingAnLLVMBackend.html#expand</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html#selectiondag-legalizetypes-phase">http://llvm.org/docs/CodeGenerator.html#selectiondag-legalizetypes-phase</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="backendstructure.html">Backend structure</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="genobj.html">Generating object files</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>