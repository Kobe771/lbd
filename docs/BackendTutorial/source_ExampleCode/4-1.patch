diff -Naur Chapter3_4/Cpu0InstrInfo.td Chapter4_1/Cpu0InstrInfo.td
--- Chapter3_4/Cpu0InstrInfo.td	2013-09-10 18:27:56.137606034 +0800
+++ Chapter4_1/Cpu0InstrInfo.td	2013-09-10 18:27:56.137606034 +0800
@@ -157,6 +157,15 @@
   let isReMaterializable = 1;
 }
 
+// Load Upper Imediate
+class LoadUpper<bits<8> op, string instr_asm, RegisterClass RC, Operand Imm>:
+  FL<op, (outs RC:$ra), (ins Imm:$imm16),
+     !strconcat(instr_asm, "\t$ra, $imm16"), [], IIAlu> {
+  let rb = 0;
+  let neverHasSideEffects = 1;
+  let isReMaterializable = 1;
+}
+
 class FMem<bits<8> op, dag outs, dag ins, string asmstr, list<dag> pattern,
           InstrItinClass itin>: FL<op, outs, ins, asmstr, pattern, itin> {
   bits<20> addr;
@@ -216,15 +225,35 @@
 
 /// Arithmetic Instructions (3-Operand, R-Type)
 def ADDu    : ArithLogicR<0x11, "addu", add, IIAlu, CPURegs, 1>;
+def SUBu    : ArithLogicR<0x12, "subu", sub, IIAlu, CPURegs>;
+def ADD     : ArithLogicR<0x13, "add", add, IIAlu, CPURegs, 1>;
+def SUB     : ArithLogicR<0x14, "sub", sub, IIAlu, CPURegs, 1>;
+def MUL     : ArithLogicR<0x17, "mul", mul, IIImul, CPURegs, 1>;
+def AND     : ArithLogicR<0x18, "and", and, IIAlu, CPURegs, 1>;
+def OR      : ArithLogicR<0x19, "or", or, IIAlu, CPURegs, 1>;
+def XOR     : ArithLogicR<0x1a, "xor", xor, IIAlu, CPURegs, 1>;
 
 /// Shift Instructions
+// sra is IR node for ashr llvm IR instruction of .bc
+def ROL     : shift_rotate_imm32<0x1b, 0x01, "rol", rotl>;
+def ROR     : shift_rotate_imm32<0x1c, 0x01, "ror", rotr>;
+def SRA     : shift_rotate_imm32<0x1d, 0x00, "sra", sra>;
 def SHL     : shift_rotate_imm32<0x1e, 0x00, "shl", shl>;
+// srl is IR node for lshr llvm IR instruction of .bc
+def SHR     : shift_rotate_imm32<0x1f, 0x00, "shr", srl>;
+def SRAV    : shift_rotate_reg<0x20, 0x00, "srav", sra, CPURegs>;
+def SHLV    : shift_rotate_reg<0x21, 0x00, "shlv", shl, CPURegs>;
+def SHRV    : shift_rotate_reg<0x22, 0x00, "shrv", srl, CPURegs>;
 
 let isReturn=1, isTerminator=1, hasDelaySlot=1, isCodeGenOnly=1,
     isBarrier=1, hasCtrlDep=1 in
   def RET : FJ <0x2c, (outs), (ins CPURegs:$target),
                 "ret\t$target", [(Cpu0Ret CPURegs:$target)], IIBranch>;
 
+/// Multiply and Divide Instructions.
+def SDIV    : Div32<Cpu0DivRem, 0x43, "div", IIIdiv>;
+def UDIV    : Div32<Cpu0DivRemU, 0x44, "divu", IIIdiv>;
+
 //===----------------------------------------------------------------------===//
 //  Arbitrary patterns that map to one or more instructions
 //===----------------------------------------------------------------------===//
diff -Naur Chapter3_4/Cpu0Schedule.td Chapter4_1/Cpu0Schedule.td
--- Chapter3_4/Cpu0Schedule.td	2013-09-10 18:27:56.137606034 +0800
+++ Chapter4_1/Cpu0Schedule.td	2013-09-10 18:27:56.141606034 +0800
@@ -11,6 +11,7 @@
 // Functional units across Cpu0 chips sets. Based on GCC/Cpu0 backend files.
 //===----------------------------------------------------------------------===//
 def ALU     : FuncUnit;
+def IMULDIV : FuncUnit;
 
 //===----------------------------------------------------------------------===//
 // Instruction Itinerary classes used for Cpu0
@@ -19,6 +20,8 @@
 def IILoad             : InstrItinClass;
 def IIStore            : InstrItinClass;
 def IIBranch           : InstrItinClass;
+def IIImul             : InstrItinClass;
+def IIIdiv             : InstrItinClass;
 
 def IIPseudo           : InstrItinClass;
 
@@ -26,9 +29,11 @@
 // Cpu0 Generic instruction itineraries.
 //===----------------------------------------------------------------------===//
 // http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html
-def Cpu0GenericItineraries : ProcessorItineraries<[ALU], [], [
+def Cpu0GenericItineraries : ProcessorItineraries<[ALU, IMULDIV], [], [
   InstrItinData<IIAlu              , [InstrStage<1,  [ALU]>]>,
   InstrItinData<IILoad             , [InstrStage<3,  [ALU]>]>,
   InstrItinData<IIStore            , [InstrStage<1,  [ALU]>]>,
-  InstrItinData<IIBranch           , [InstrStage<1,  [ALU]>]>
+  InstrItinData<IIBranch           , [InstrStage<1,  [ALU]>]>,
+  InstrItinData<IIImul             , [InstrStage<17, [IMULDIV]>]>,
+  InstrItinData<IIIdiv             , [InstrStage<38, [IMULDIV]>]>
 ]>;
