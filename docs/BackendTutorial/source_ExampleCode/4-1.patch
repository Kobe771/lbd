diff -Naur Chapter3_4/Cpu0InstrInfo.td Chapter4_1/Cpu0InstrInfo.td
--- Chapter3_4/Cpu0InstrInfo.td	2013-07-15 13:41:33.972210288 +0800
+++ Chapter4_1/Cpu0InstrInfo.td	2013-07-15 13:41:33.968210288 +0800
@@ -132,6 +132,15 @@
                          SDNode OpNode>:
   shift_rotate_imm<func, isRotate, instr_asm, OpNode, immZExt5, shamt, CPURegs>;
 
+// Load Upper Imediate
+class LoadUpper<bits<8> op, string instr_asm, RegisterClass RC, Operand Imm>:
+  FL<op, (outs RC:$ra), (ins Imm:$imm16),
+     !strconcat(instr_asm, "\t$ra, $imm16"), [], IIAlu> {
+  let rb = 0;
+  let neverHasSideEffects = 1;
+  let isReMaterializable = 1;
+}
+
 class FMem<bits<8> op, dag outs, dag ins, string asmstr, list<dag> pattern,
           InstrItinClass itin>: FL<op, outs, ins, asmstr, pattern, itin> {
   bits<20> addr;
@@ -190,9 +199,23 @@
 
 /// Arithmetic Instructions (3-Operand, R-Type)
 def ADDu    : ArithLogicR<0x11, "addu", add, IIAlu, CPURegs, 1>;
+def ADD     : ArithLogicR<0x13, "add", add, IIAlu, CPURegs, 1>;
+def SUB     : ArithLogicR<0x14, "sub", sub, IIAlu, CPURegs, 1>;
+def MUL     : ArithLogicR<0x15, "mul", mul, IIImul, CPURegs, 1>;
+def DIV     : ArithLogicR<0x16, "div", sdiv, IIIdiv, CPURegs, 1>;
+def UDIV    : ArithLogicR<0x17, "udiv", udiv, IIIdiv, CPURegs, 1>;
+def AND     : ArithLogicR<0x18, "and", and, IIAlu, CPURegs, 1>;
+def OR      : ArithLogicR<0x19, "or", or, IIAlu, CPURegs, 1>;
+def XOR     : ArithLogicR<0x1A, "xor", xor, IIAlu, CPURegs, 1>;
 
 /// Shift Instructions
+// sra is IR node for ashr llvm IR instruction of .bc
+def SRA     : shift_rotate_imm32<0x1B, 0x00, "sra", sra>;
+def ROL     : shift_rotate_imm32<0x1C, 0x01, "rol", rotl>;
+def ROR     : shift_rotate_imm32<0x1D, 0x01, "ror", rotr>;
 def SHL     : shift_rotate_imm32<0x1E, 0x00, "shl", shl>;
+// srl is IR node for lshr llvm IR instruction of .bc
+def SHR     : shift_rotate_imm32<0x1F, 0x00, "shr", srl>;
 
 let isReturn=1, isTerminator=1, hasDelaySlot=1, isCodeGenOnly=1,
     isBarrier=1, hasCtrlDep=1 in
diff -Naur Chapter3_4/Cpu0Schedule.td Chapter4_1/Cpu0Schedule.td
--- Chapter3_4/Cpu0Schedule.td	2013-07-15 13:41:33.972210288 +0800
+++ Chapter4_1/Cpu0Schedule.td	2013-07-15 13:41:33.968210288 +0800
@@ -11,6 +11,7 @@
 // Functional units across Cpu0 chips sets. Based on GCC/Cpu0 backend files.
 //===----------------------------------------------------------------------===//
 def ALU     : FuncUnit;
+def IMULDIV : FuncUnit;
 
 //===----------------------------------------------------------------------===//
 // Instruction Itinerary classes used for Cpu0
@@ -19,6 +20,8 @@
 def IILoad             : InstrItinClass;
 def IIStore            : InstrItinClass;
 def IIBranch           : InstrItinClass;
+def IIImul             : InstrItinClass;
+def IIIdiv             : InstrItinClass;
 
 def IIPseudo           : InstrItinClass;
 
@@ -26,9 +29,11 @@
 // Cpu0 Generic instruction itineraries.
 //===----------------------------------------------------------------------===//
 // http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html
-def Cpu0GenericItineraries : ProcessorItineraries<[ALU], [], [
+def Cpu0GenericItineraries : ProcessorItineraries<[ALU, IMULDIV], [], [
   InstrItinData<IIAlu              , [InstrStage<1,  [ALU]>]>,
   InstrItinData<IILoad             , [InstrStage<3,  [ALU]>]>,
   InstrItinData<IIStore            , [InstrStage<1,  [ALU]>]>,
-  InstrItinData<IIBranch           , [InstrStage<1,  [ALU]>]>
+  InstrItinData<IIBranch           , [InstrStage<1,  [ALU]>]>,
+  InstrItinData<IIImul             , [InstrStage<17, [IMULDIV]>]>,
+  InstrItinData<IIIdiv             , [InstrStage<38, [IMULDIV]>]>
 ]>;
