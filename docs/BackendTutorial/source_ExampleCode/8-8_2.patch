diff -Naur Chapter8_8/Cpu0InstrInfo.cpp Chapter8_8_2/Cpu0InstrInfo.cpp
--- Chapter8_8/Cpu0InstrInfo.cpp	2013-07-05 17:46:02.917283807 +0800
+++ Chapter8_8_2/Cpu0InstrInfo.cpp	2013-07-05 17:46:02.869283807 +0800
@@ -29,6 +29,7 @@
   return RI;
 }
 
+//- Called when DestReg and SrcReg belong to different Register Class.
 void Cpu0InstrInfo::
 copyPhysReg(MachineBasicBlock &MBB,
             MachineBasicBlock::iterator I, DebugLoc DL,
@@ -45,6 +46,8 @@
       Opc = Cpu0::MFLO, SrcReg = 0;
     else if (SrcReg == Cpu0::SW)	// add $ra, $ZERO, $SW
       Opc = Cpu0::ADD, ZeroReg = Cpu0::ZERO;
+    else if (SrcReg == Cpu0::ACC)
+      Opc = Cpu0::MFACC, SrcReg = 0;
   }
   else if (Cpu0::CPURegsRegClass.contains(SrcReg)) { // Copy from CPU Reg.
     if (DestReg == Cpu0::HI)
@@ -55,6 +58,8 @@
     //  cmp $SW, $ZERO, $rc
     else if (DestReg == Cpu0::SW)
       Opc = Cpu0::CMP, ZeroReg = Cpu0::ZERO;
+    else if (DestReg == Cpu0::ACC)
+      Opc = Cpu0::MTACC, DestReg = 0;
   }
 
   assert(Opc && "Cannot copy registers");
diff -Naur Chapter8_8/Cpu0InstrInfo.td Chapter8_8_2/Cpu0InstrInfo.td
--- Chapter8_8/Cpu0InstrInfo.td	2013-07-05 17:46:02.913283807 +0800
+++ Chapter8_8_2/Cpu0InstrInfo.td	2013-07-05 17:46:02.869283807 +0800
@@ -346,6 +346,36 @@
   let neverHasSideEffects = 1;
 }
 
+class MoveFromACC<bits<8> op, string instr_asm, RegisterClass RC,
+                   list<Register> UseRegs>:
+  FL<op, (outs RC:$ra), (ins),
+     !strconcat(instr_asm, "\t$ra"), [], IIAlu> {
+  let rb = 0;
+  let imm16 = 0;
+  let Uses = UseRegs;
+  let neverHasSideEffects = 1;
+}
+
+class MoveToACC<bits<8> op, string instr_asm, RegisterClass RC,
+                 list<Register> DefRegs>:
+  FL<op, (outs), (ins RC:$ra),
+     !strconcat(instr_asm, "\t$ra"), [], IIAlu> {
+  let rb = 0;
+  let imm16 = 0;
+  let Defs = DefRegs;
+  let neverHasSideEffects = 1;
+}
+
+class ArithLogicUniR2<bits<8> op, string instr_asm, RegisterClass RC1,
+                 RegisterClass RC2, list<Register> DefRegs>:
+  FL<op, (outs), (ins RC1:$accum, RC2:$ra),
+     !strconcat(instr_asm, "\t$ra"), [], IIAlu> {
+  let rb = 0;
+  let imm16 = 0;
+  let Defs = DefRegs;
+  let neverHasSideEffects = 1;
+}
+
 class EffectiveAddress<string instr_asm, RegisterClass RC, Operand Mem> :
   FMem<0x09, (outs RC:$ra), (ins Mem:$addr),
      instr_asm, [(set RC:$ra, addr:$addr)], IIAlu>;
@@ -416,6 +446,10 @@
 def MTHI : MoveToLOHI<0x42, "mthi", CPURegs, [HI]>;
 def MTLO : MoveToLOHI<0x43, "mtlo", CPURegs, [LO]>;
 
+def MFACC : MoveFromACC<0x44, "mfacc", CPURegs, [ACC]>;
+def MTACC : MoveToACC<0x45, "mtacc", CPURegs, [ACC]>;
+def ADD   : ArithLogicUniR2<0x46, "add", RACC, CPURegs, [ACC]>;
+
 /// Shift Instructions
 // sra is IR node for ashr llvm IR instruction of .bc
 def SRA     : shift_rotate_imm32<0x1B, 0x00, "sra", sra>;
@@ -494,6 +528,12 @@
 def : Pat<(i32 (extloadi8  addr:$src)), (LBu addr:$src)>;
 def : Pat<(i32 (extloadi16_a addr:$src)), (LHu addr:$src)>;
 
+def : Pat<(add RACC:$lhs, CPURegs:$rhs),
+          (ADD RACC:$lhs, CPURegs:$rhs)>;
+
+def : Pat<(add CPURegs:$lhs, CPURegs:$rhs),
+          (ADD (MTACC CPURegs:$lhs), CPURegs:$rhs)>;
+
 // brcond patterns
 multiclass BrcondPats<RegisterClass RC, Instruction JEQOp, Instruction JNEOp, 
 Instruction JLTOp, Instruction JGTOp, Instruction JLEOp, Instruction JGEOp, 
