

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Backend structure &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.2.15',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Adding arithmetic and local pointer support" href="otherinst.html" />
    <link rel="prev" title="Cpu0 Instruction Set and LLVM Target Description" href="llvmstructure.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Backend structure</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="llvmstructure.html">Cpu0 Instruction Set and LLVM Target Description</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="otherinst.html">Adding arithmetic and local pointer support</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="backend-structure">
<span id="sec-backendstructure"></span><h1>Backend structure<a class="headerlink" href="#backend-structure" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduce the back end class inherit tree and class members first.
Next, following the back end structure, adding individual class implementation
in each section.
There are compiler knowledge like DAG (Directed-Acyclic-Graph) and instruction
selection needed in this chapter.
This chapter explains these knowledge just when needed.
At the end of this chapter, we will have a back end to compile llvm
intermediate code into cpu0 assembly code.</p>
<p>Many code are added in this chapter. They almost are common in every back end
except the back end name (cpu0 or mips ...). Actually, we copy almost all the
code from mips and replace the name with cpu0. Please focus on the classes
relationship in this backend structure. Once knowing the structure, you can
create your backend structure as quickly as we did, even though there are 3000
lines of code in this chapter.</p>
<div class="section" id="targetmachine-structure">
<h2>TargetMachine structure<a class="headerlink" href="#targetmachine-structure" title="Permalink to this headline">¶</a></h2>
<p>Your back end should define a TargetMachine class, for example, we define the
Cpu0TargetMachine class.
Cpu0TargetMachine class contains it&#8217;s own instruction class, frame/stack class,
DAG (Directed-Acyclic-Graph) class, and register class.
The Cpu0TargetMachine contents as follows,</p>
<p class="rubric">include/llvm/Target/Cpu0TargetMachine.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- TargetMachine.h</span>
<span class="k">class</span> <span class="nc">TargetMachine</span> <span class="p">{</span>
  <span class="n">TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Interfaces to the major aspects of target machine information:</span>
  <span class="c1">// -- Instruction opcode and operand information</span>
  <span class="c1">// -- Pipelines and scheduling information</span>
  <span class="c1">// -- Stack frame information</span>
  <span class="c1">// -- Selection DAG lowering information</span>
  <span class="c1">//</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetInstrInfo</span>         <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">getFrameLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetLowering</span>    <span class="o">*</span><span class="n">getTargetLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetSelectionDAGInfo</span> <span class="o">*</span><span class="n">getSelectionDAGInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">DataLayout</span>             <span class="o">*</span><span class="n">getDataLayout</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">...</span>
  <span class="c1">/// getSubtarget - This method returns a pointer to the specified type of</span>
  <span class="c1">/// TargetSubtargetInfo.  In debug builds, it verifies that the object being</span>
  <span class="c1">/// returned is of the correct type.</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">STC</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">STC</span> <span class="o">&amp;</span><span class="n">getSubtarget</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">STC</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">getSubtargetImpl</span><span class="p">());</span>
  <span class="p">}</span>

<span class="p">}</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">LLVMTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetMachine</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span> <span class="c1">// Can only create subclasses.</span>
  <span class="n">LLVMTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TargetTriple</span><span class="p">,</span>
          <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="n">TargetOptions</span> <span class="n">Options</span><span class="p">,</span>
          <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
          <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0TargetMachine.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0TargetMachine.h - Define TargetMachine for Cpu0 -----*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file declares the Cpu0 specific subclass of TargetMachine.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0TARGETMACHINE_H</span>
<span class="cp">#define CPU0TARGETMACHINE_H</span>

<span class="cp">#include &quot;Cpu0FrameLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0ISelLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0SelectionDAGInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/DataLayout.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetFrameLowering.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">formatted_raw_ostream</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Cpu0TargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LLVMTargetMachine</span> <span class="p">{</span>
    <span class="n">Cpu0Subtarget</span>       <span class="n">Subtarget</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">DataLayout</span>    <span class="n">DL</span><span class="p">;</span> <span class="c1">// Calculates type size &amp; alignment</span>
    <span class="n">Cpu0InstrInfo</span>       <span class="n">InstrInfo</span><span class="p">;</span>	<span class="c1">//- Instructions</span>
    <span class="n">Cpu0FrameLowering</span>   <span class="n">FrameLowering</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0TargetLowering</span>  <span class="n">TLInfo</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0SelectionDAGInfo</span> <span class="n">TSInfo</span><span class="p">;</span>	<span class="c1">//- Map .bc DAG to backend DAG</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">,</span>
                      <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0InstrInfo</span>   <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">getFrameLowering</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">FrameLowering</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0Subtarget</span>   <span class="o">*</span><span class="n">getSubtargetImpl</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">DataLayout</span> <span class="o">*</span><span class="n">getDataLayout</span><span class="p">()</span>    <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">;}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0TargetLowering</span> <span class="o">*</span><span class="n">getTargetLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TLInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0SelectionDAGInfo</span><span class="o">*</span> <span class="n">getSelectionDAGInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TSInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Pass Pipeline Configuration</span>
    <span class="k">virtual</span> <span class="n">TargetPassConfig</span> <span class="o">*</span><span class="n">createPassConfig</span><span class="p">(</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">);</span>
  <span class="p">};</span>

<span class="c1">/// Cpu0ebTargetMachine - Cpu032 big endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0ebTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0ebTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">/// Cpu0elTargetMachine - Cpu032 little endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0elTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0elTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">include/llvm/Target/TargetInstInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TargetInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCInstrInfo</span> <span class="p">{</span>
  <span class="n">TargetInstrInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">TargetInstrInfoImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfo</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="n">TargetInstrInfoImpl</span><span class="p">(</span><span class="kt">int</span> <span class="n">CallFrameSetupOpcode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">CallFrameDestroyOpcode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetInstrInfo</span><span class="p">(</span><span class="n">CallFrameSetupOpcode</span><span class="p">,</span> <span class="n">CallFrameDestroyOpcode</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">cmake_debug_build/lib/Target/Cpu0/Cpu0GenInstInfo.inc</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0GenInstInfo.inc which generate from Cpu0InstrInfo.td</span>
<span class="cp">#ifdef GET_INSTRINFO_HEADER</span>
<span class="cp">#undef GET_INSTRINFO_HEADER</span>
<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">Cpu0GenInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfoImpl</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">SO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">DO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>
<span class="cp">#endif </span><span class="c1">// GET_INSTRINFO_HEADER</span>

<span class="cp">#define GET_INSTRINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>
<span class="c1">//- Cpu0InstInfo.h</span>
<span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="figure align-center" id="backendstructure-f1">
<img alt="_images/1.png" src="_images/1.png" />
<p class="caption">Figure 1: TargetMachine class diagram 1</p>
</div>
<p>The Cpu0TargetMachine inherit tree is TargetMachine &lt;- LLVMTargetMachine &lt;-
Cpu0TargetMachine.
Cpu0TargetMachine has class Cpu0Subtarget, Cpu0InstrInfo, Cpu0FrameLowering,
Cpu0TargetLowering and Cpu0SelectionDAGInfo.
Class Cpu0Subtarget, Cpu0InstrInfo, Cpu0FrameLowering, Cpu0TargetLowering and
Cpu0SelectionDAGInfo are inherited from parent class TargetSubtargetInfo,
TargetInstrInfo, TargetFrameLowering, TargetLowering and TargetSelectionDAGInfo.</p>
<p><a class="pageref" href="#backendstructure-f1">Figure  1</a> shows Cpu0TargetMachine inherit tree and it&#8217;s
Cpu0InstrInfo class inherit tree.
Cpu0TargetMachine contains Cpu0InstrInfo and ... other class.
Cpu0InstrInfo contains Cpu0RegisterInfo class, RI. Cpu0InstrInfo.td and
Cpu0RegisterInfo.td will generate Cpu0GenInstrInfo.inc and
Cpu0GenRegisterInfo.inc which contain some member functions implementation for
class Cpu0InstrInfo and Cpu0RegisterInfo.</p>
<p><a class="pageref" href="#backendstructure-f2">Figure  2</a> as below shows Cpu0TargetMachine contains
class
TSInfo: Cpu0SelectionDAGInfo, FrameLowering: Cpu0FrameLowering, Subtarget:
Cpu0Subtarget and TLInfo: Cpu0TargetLowering.</p>
<div class="figure align-center" id="backendstructure-f2">
<img alt="_images/2.png" src="_images/2.png" />
<p class="caption">Figure 2: TargetMachine class diagram 2</p>
</div>
<div class="figure align-center" id="backendstructure-f3">
<img alt="_images/3.png" src="_images/3.png" />
<p class="caption">Figure 3: TargetMachine members and operators</p>
</div>
<p><a class="pageref" href="#backendstructure-f3">Figure  3</a> shows some members and operators (member function)
of the parent class TargetMachine&#8217;s.
<a class="pageref" href="#backendstructure-f4">Figure  4</a> as below shows some members of class InstrInfo,
RegisterInfo and TargetLowering.
Class DAGInfo is skipped here.</p>
<div class="figure align-center" id="backendstructure-f4">
<img alt="_images/4.png" src="_images/4.png" />
<p class="caption">Figure 4: Other class members and operators</p>
</div>
<p>Benefit from the inherit tree structure, we just need to implement few code in
instruction, frame/stack, select DAG class.
Many code implemented by their parent class.
The llvm-tblgen generate Cpu0GenInstrInfo.inc from Cpu0InstrInfo.td.
Cpu0InstrInfo.h extract those code it need from Cpu0GenInstrInfo.inc by define
“#define GET_INSTRINFO_HEADER”.
Following is the code fragment from Cpu0GenInstrInfo.inc.
Code between “#if def  GET_INSTRINFO_HEADER” and “#endif // GET_INSTRINFO_HEADER”
will be extracted by Cpu0InstrInfo.h.</p>
<p class="rubric">cmake_debug_build/lib/Target/Cpu0/Cpu0GenInstInfo.inc</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0GenInstInfo.inc which generate from Cpu0InstrInfo.td</span>
<span class="cp">#ifdef GET_INSTRINFO_HEADER</span>
<span class="cp">#undef GET_INSTRINFO_HEADER</span>
<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">Cpu0GenInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfoImpl</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">SO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">DO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>
<span class="cp">#endif </span><span class="c1">// GET_INSTRINFO_HEADER</span>
</pre></div>
</div>
<p>Reference Write An LLVM Backend web site <a class="footnote-reference" href="#id5" id="id1">[1]</a>.</p>
<p>Now, the code in Chapter3_1/ add class Cpu0TargetMachine(Cpu0TargetMachine.h and
cpp), Cpu0Subtarget (Cpu0Subtarget.h and .cpp), Cpu0InstrInfo (Cpu0InstrInfo.h
and .cpp), Cpu0FrameLowering (Cpu0FrameLowering.h and .cpp), Cpu0TargetLowering
(Cpu0ISelLowering.h and .cpp) and Cpu0SelectionDAGInfo ( Cpu0SelectionDAGInfo.h
and .cpp).
CMakeLists.txt  modified with those new added *.cpp as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/CMakeLists.txt</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp"># Cpu0CodeGen should match with LLVMBuild.txt Cpu0CodeGen</span>
<span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span>
  <span class="n">Cpu0ISelLowering</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0InstrInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0FrameLowering</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0Subtarget</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0TargetMachine</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0SelectionDAGInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>Please take a look for Chapter3_1 code.
After that, building Chapter3_1 by make as chapter 2 (of course, you should remove old
src/lib/Target/Cpu0 and replace with src/lib/Target/Cpu0/LLVMBackendTutorialExampleCode/Chapter3_1/).
You can remove cmake_debug_build/lib/Target/Cpu0/*.inc before do “make” to ensure your code
rebuild completely.
By remove *.inc, all files those have included .inc will be rebuild, then your
Target library will regenerate.
Command as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:cmake_debug_build Jonathan<span class="nv">$ </span>rm -rf lib/Target/Cpu0/*
</pre></div>
</div>
</div>
<div class="section" id="add-registerinfo">
<h2>Add RegisterInfo<a class="headerlink" href="#add-registerinfo" title="Permalink to this headline">¶</a></h2>
<p>As depicted in <a class="pageref" href="#backendstructure-f1">Figure  1</a>, the Cpu0InstrInfo class should
contains Cpu0RegisterInfo.
So Chapter3_2/ add Cpu0RegisterInfo class (Cpu0RegisterInfo.h,
Cpu0RegisterInfo.cpp), and Cpu0RegisterInfo class in files Cpu0InstrInfo.h,
Cpu0InstrInfo.cpp, Cpu0TargetMachine.h, and modify CMakeLists.txt as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0RegisterInfo.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0RegisterInfo.h - Cpu0 Register Information Impl -----*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the Cpu0 implementation of the TargetRegisterInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0REGISTERINFO_H</span>
<span class="cp">#define CPU0REGISTERINFO_H</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetRegisterInfo.h&quot;</span>

<span class="cp">#define GET_REGINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenRegisterInfo.inc&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0Subtarget</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">TargetInstrInfo</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Type</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenRegisterInfo</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span><span class="p">;</span>

  <span class="n">Cpu0RegisterInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="n">tii</span><span class="p">);</span>

  <span class="c1">/// getRegisterNumbering - Given the enum value for some register, e.g.</span>
  <span class="c1">/// Cpu0::RA, return the number that it corresponds to (e.g. 31).</span>
  <span class="k">static</span> <span class="kt">unsigned</span> <span class="n">getRegisterNumbering</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegEnum</span><span class="p">);</span>

  <span class="c1">/// Code Generation virtual methods...</span>
  <span class="k">const</span> <span class="n">uint16_t</span> <span class="o">*</span><span class="n">getCalleeSavedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span><span class="o">*</span> <span class="n">MF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">uint32_t</span> <span class="o">*</span><span class="n">getCallPreservedMask</span><span class="p">(</span><span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// pure virtual method</span>
  <span class="n">BitVector</span> <span class="n">getReservedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// pure virtual method</span>
  <span class="c1">/// Stack Frame Processing Methods</span>
  <span class="kt">void</span> <span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span>
                           <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span>
                           <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// pure virtual method</span>
  <span class="c1">/// Debug information queries.</span>
  <span class="kt">unsigned</span> <span class="n">getFrameRegister</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace llvm</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0RegisterInfo.cpp - CPU0 Register Information -== --------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the CPU0 implementation of the TargetRegisterInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-reg-info&quot;</span>

<span class="cp">#include &quot;Cpu0RegisterInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Constants.h&quot;</span>
<span class="cp">#include &quot;llvm/DebugInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Type.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Function.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/ValueTypes.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetFrameLowering.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetOptions.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetInstrInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/CommandLine.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Debug.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/BitVector.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/STLExtras.h&quot;</span>

<span class="cp">#define GET_REGINFO_TARGET_DESC</span>
<span class="cp">#include &quot;Cpu0GenRegisterInfo.inc&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0RegisterInfo</span><span class="o">::</span><span class="n">Cpu0RegisterInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">ST</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="n">tii</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">Cpu0GenRegisterInfo</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">ST</span><span class="p">),</span> <span class="n">TII</span><span class="p">(</span><span class="n">tii</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Callee Saved Registers methods</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">/// Cpu0 Callee Saved Registers</span>
<span class="c1">// In Cpu0CallConv.td,</span>
<span class="c1">// def CSR_O32 : CalleeSavedRegs&lt;(add LR, FP,</span>
<span class="c1">//                                   (sequence &quot;S%u&quot;, 2, 0))&gt;;</span>
<span class="c1">// llc create CSR_O32_SaveList and CSR_O32_RegMask from above defined.</span>
<span class="k">const</span> <span class="n">uint16_t</span><span class="o">*</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getCalleeSavedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">*</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">CSR_O32_SaveList</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">uint32_t</span><span class="o">*</span>
<span class="n">Cpu0RegisterInfo</span><span class="o">::</span><span class="n">getCallPreservedMask</span><span class="p">(</span><span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">CSR_O32_RegMask</span><span class="p">;</span> 
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
<span class="n">BitVector</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getReservedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">uint16_t</span> <span class="n">ReservedCPURegs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">AT</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">,</span>
    <span class="n">Cpu0</span><span class="o">::</span><span class="n">SW</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">PC</span>
  <span class="p">};</span>
  <span class="n">BitVector</span> <span class="n">Reserved</span><span class="p">(</span><span class="n">getNumRegs</span><span class="p">());</span>
  <span class="k">typedef</span> <span class="n">TargetRegisterClass</span><span class="o">::</span><span class="n">iterator</span> <span class="n">RegIter</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">array_lengthof</span><span class="p">(</span><span class="n">ReservedCPURegs</span><span class="p">);</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="n">Reserved</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">ReservedCPURegs</span><span class="p">[</span><span class="n">I</span><span class="p">]);</span>

  <span class="k">return</span> <span class="n">Reserved</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
<span class="c1">// FrameIndex represent objects inside a abstract stack.</span>
<span class="c1">// We must replace FrameIndex with an stack/frame pointer</span>
<span class="c1">// direct reference.</span>
<span class="kt">void</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
<span class="kt">unsigned</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getFrameRegister</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">TFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getFrameLowering</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">TFI</span><span class="o">-&gt;</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">)</span> <span class="o">:</span>
                          <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0InstrInfo.h - Cpu0 Instruction Information ----------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the Cpu0 implementation of the TargetInstrInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0INSTRUCTIONINFO_H</span>
<span class="cp">#define CPU0INSTRUCTIONINFO_H</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0RegisterInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetInstrInfo.h&quot;</span>

<span class="cp">#define GET_INSTRINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="n">RI</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>

  <span class="c1">/// getRegisterInfo - TargetInstrInfo is a superset of MRegister info.  As</span>
  <span class="c1">/// such, whenever a client has an instance of instruction info, it should</span>
  <span class="c1">/// always be able to get register info as well (through this method).</span>
  <span class="c1">///</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">&amp;</span><span class="n">getRegisterInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0InstrInfo.cpp - Cpu0 Instruction Information ------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the Cpu0 implementation of the TargetInstrInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#define GET_INSTRINFO_CTOR</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span>
  <span class="o">:</span> 
    <span class="n">TM</span><span class="p">(</span><span class="n">tm</span><span class="p">),</span>
    <span class="n">RI</span><span class="p">(</span><span class="o">*</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtargetImpl</span><span class="p">(),</span> <span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">&amp;</span><span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">getRegisterInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">RI</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0TargetMachine.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre>    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">*</span><span class="n">getRegisterInfo</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">.</span><span class="n">getRegisterInfo</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp"># CMakeLists.txt</span>
<span class="p">...</span>
<span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span>
  <span class="p">...</span>
  <span class="n">Cpu0RegisterInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>Now, let&#8217;s replace Chapter3_1/ with Chapter3_2/ of adding register class definition
as command below and rebuild.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-75-57:ExampleCode Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/llvm/test/src/lib/Target/Cpu0/LLVMBackendTutorialExampleCode
118-165-75-57:LLVMBackendTutorialExampleCode Jonathan<span class="nv">$ </span>sh removecpu0.sh
118-165-75-57:LLVMBackendTutorialExampleCode Jonathan<span class="nv">$ </span>cp -rf Chapter3_2/
* ../.
</pre></div>
</div>
<p>After that, let&#8217;s try to run the <tt class="docutils literal"><span class="pre">llc</span></tt> compile command to see what happen,</p>
<div class="highlight-bash"><pre>118-165-78-230:InputFiles Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o
ch3.cpu0.s
Assertion failed: (AsmInfo &amp;&amp; "MCAsmInfo not initialized." "Make sure you includ
...</pre>
</div>
<p>The errors say that we have not Target AsmPrinter.
Let&#8217;s add it in next section.</p>
</div>
<div class="section" id="add-asmprinter">
<h2>Add AsmPrinter<a class="headerlink" href="#add-asmprinter" title="Permalink to this headline">¶</a></h2>
<p>Chapter3_3/cpu0 contains the Cpu0AsmPrinter definition. First, we add definitions in
Cpu0.td to support AssemblyWriter.
Cpu0.td is added with the following fragment,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0.td</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 processors supported.</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">Proc</span><span class="o">&lt;</span><span class="n">string</span> <span class="n">Name</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">SubtargetFeature</span><span class="o">&gt;</span> <span class="n">Features</span><span class="o">&gt;</span>
 <span class="o">:</span> <span class="n">Processor</span><span class="o">&lt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">Cpu0GenericItineraries</span><span class="p">,</span> <span class="n">Features</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="o">:</span> <span class="n">Proc</span><span class="o">&lt;</span><span class="s">&quot;cpu032&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">FeatureCpu032</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="n">Cpu0AsmWriter</span> <span class="o">:</span> <span class="n">AsmWriter</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">AsmWriterClassName</span>  <span class="o">=</span> <span class="s">&quot;InstPrinter&quot;</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isMCAsmWriter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Will generate Cpu0GenAsmWrite.inc included by Cpu0InstPrinter.cpp, contents </span>
<span class="c1">//  as follows,</span>
<span class="c1">// void Cpu0InstPrinter::printInstruction(const MCInst *MI, raw_ostream &amp;O) {...}</span>
<span class="c1">// const char *Cpu0InstPrinter::getRegisterName(unsigned RegNo) {...}</span>
<span class="n">def</span> <span class="n">Cpu0</span> <span class="o">:</span> <span class="n">Target</span> <span class="p">{</span>
<span class="c1">// def Cpu0InstrInfo : InstrInfo as before.</span>
  <span class="n">let</span> <span class="n">InstructionSet</span> <span class="o">=</span> <span class="n">Cpu0InstrInfo</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">AssemblyWriters</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmWriter</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>As comments indicate, it will generate Cpu0GenAsmWrite.inc which is included
by Cpu0InstPrinter.cpp.
Cpu0GenAsmWrite.inc has the implementation of
Cpu0InstPrinter::printInstruction() and Cpu0InstPrinter::getRegisterName().
Both of these functions can be auto-generated from the information we defined
in Cpu0InstrInfo.td and Cpu0RegisterInfo.td.
To let these two functions work in our code, the only thing need to do is add a
class Cpu0InstPrinter and include them.</p>
<p>File Chapter3_3/Cpu0/InstPrinter/Cpu0InstPrinter.cpp include Cpu0GenAsmWrite.inc and
call the auto-generated functions as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/InstPrinter/Cpu0InstPrinter.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//=== Cpu0InstPrinter.h - Convert Cpu0 MCInst to assembly syntax -*- C++ -*-==//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This class prints a Cpu0 MCInst to a .s file.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0INSTPRINTER_H</span>
<span class="cp">#define CPU0INSTPRINTER_H</span>
<span class="cp">#include &quot;llvm/MC/MCInstPrinter.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="c1">// These enumeration declarations were orignally in Cpu0InstrInfo.h but</span>
<span class="c1">// had to be moved here to avoid circular dependencies between</span>
<span class="c1">// LLVMCpu0CodeGen and LLVMCpu0AsmPrinter.</span>

<span class="k">class</span> <span class="nc">TargetMachine</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Cpu0InstPrinter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCInstPrinter</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0InstPrinter</span><span class="p">(</span><span class="k">const</span> <span class="n">MCAsmInfo</span> <span class="o">&amp;</span><span class="n">MAI</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MII</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">MCInstPrinter</span><span class="p">(</span><span class="n">MAI</span><span class="p">,</span> <span class="n">MII</span><span class="p">,</span> <span class="n">MRI</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Autogenerated by tblgen.</span>
  <span class="kt">void</span> <span class="n">printInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getRegisterName</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegNo</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">printRegName</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RegNo</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">printInst</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Annot</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">printOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">printUnsignedImm</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">printMemOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// end namespace llvm</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/InstPrinter/Cpu0InstPrinter.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0InstPrinter.cpp - Convert Cpu0 MCInst to assembly syntax ------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This class prints an Cpu0 MCInst to a .s file.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;asm-printer&quot;</span>
<span class="cp">#include &quot;Cpu0InstPrinter.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/StringExtras.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInst.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInstrInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSymbol.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="cp">#include &quot;Cpu0GenAsmWriter.inc&quot;</span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printRegName</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RegNo</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="c1">//- getRegisterName(RegNo) defined in Cpu0GenAsmWriter.inc which came from </span>
<span class="c1">//   Cpu0.td indicate.</span>
  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;$&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">StringRef</span><span class="p">(</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">RegNo</span><span class="p">)).</span><span class="n">lower</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printInst</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span>
                                <span class="n">StringRef</span> <span class="n">Annot</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//- printInstruction(MI, O) defined in Cpu0GenAsmWriter.inc which came from </span>
<span class="c1">//   Cpu0.td indicate.</span>
  <span class="n">printInstruction</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
  <span class="n">printAnnotation</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="n">Annot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">printExpr</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">Offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCSymbolRefExpr</span> <span class="o">*</span><span class="n">SRE</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">MCBinaryExpr</span> <span class="o">*</span><span class="n">BE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCBinaryExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">SRE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BE</span><span class="o">-&gt;</span><span class="n">getLHS</span><span class="p">());</span>
    <span class="k">const</span> <span class="n">MCConstantExpr</span> <span class="o">*</span><span class="n">CE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCConstantExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BE</span><span class="o">-&gt;</span><span class="n">getRHS</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">SRE</span> <span class="o">&amp;&amp;</span> <span class="n">CE</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Binary expression must be sym+const.&quot;</span><span class="p">);</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">CE</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">SRE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">)))</span>
    <span class="n">assert</span><span class="p">(</span><span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Unexpected MCExpr type.&quot;</span><span class="p">);</span>

  <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">SRE</span><span class="o">-&gt;</span><span class="n">getKind</span><span class="p">();</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span>                                 <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Invalid kind!&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="nl">VK_None:</span>           <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="n">SRE</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;+&#39;</span><span class="p">;</span>
    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="n">Offset</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GPOFF_HI</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GPOFF_LO</span><span class="p">))</span>
    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)))&quot;</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Kind</span> <span class="o">!=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_None</span><span class="p">)</span>
    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                                   <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">Op</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpNo</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">isReg</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">printRegName</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="n">Op</span><span class="p">.</span><span class="n">getReg</span><span class="p">());</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">isImm</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">Op</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">isExpr</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;unknown operand kind in printOperand&quot;</span><span class="p">);</span>
  <span class="n">printExpr</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getExpr</span><span class="p">(),</span> <span class="n">O</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printUnsignedImm</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span>
                                       <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">opNum</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isImm</span><span class="p">())</span>
    <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span><span class="p">)</span><span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="n">printOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span>
<span class="n">printMemOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Load/Store memory operands -- imm($reg)</span>
  <span class="c1">// If PIC target the target is loaded as the</span>
  <span class="c1">// pattern ld $t9,%call24($gp)</span>
  <span class="n">printOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">opNum</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;(&quot;</span><span class="p">;</span>
  <span class="n">printOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Next, Cpu0MCInstLower (Cpu0MCInstLower.h, Cpu0MCInstLower.cpp), as well as
Cpu0BaseInfo.h,
Cpu0FixupKinds.h and Cpu0MCAsmInfo (Cpu0MCAsmInfo.h, Cpu0MCAsmInfo.cpp) in
sub-directory MCTargetDesc as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0MCInstLower.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCInstLower.h - Lower MachineInstr to MCInst -------*- C++ -*--===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0MCINSTLOWER_H</span>
<span class="cp">#define CPU0MCINSTLOWER_H</span>
<span class="cp">#include &quot;llvm/ADT/SmallVector.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Compiler.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">MCContext</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MCInst</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MCOperand</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MachineInstr</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MachineFunction</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">Mangler</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">Cpu0AsmPrinter</span><span class="p">;</span>

<span class="c1">/// Cpu0MCInstLower - This class is used to lower an MachineInstr into an</span>
<span class="c1">//                    MCInst.</span>
<span class="k">class</span> <span class="nc">LLVM_LIBRARY_VISIBILITY</span> <span class="n">Cpu0MCInstLower</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MachineOperandType</span> <span class="n">MachineOperandType</span><span class="p">;</span>
  <span class="n">MCContext</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">;</span>
  <span class="n">Mangler</span> <span class="o">*</span><span class="n">Mang</span><span class="p">;</span>
  <span class="n">Cpu0AsmPrinter</span> <span class="o">&amp;</span><span class="n">AsmPrinter</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0MCInstLower</span><span class="p">(</span><span class="n">Cpu0AsmPrinter</span> <span class="o">&amp;</span><span class="n">asmprinter</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">Initialize</span><span class="p">(</span><span class="n">Mangler</span> <span class="o">*</span><span class="n">mang</span><span class="p">,</span> <span class="n">MCContext</span><span class="o">*</span> <span class="n">C</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">Lower</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">OutMI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">MCOperand</span> <span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                               <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">MCOperand</span> <span class="n">LowerOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span><span class="o">&amp;</span> <span class="n">MO</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0MCInstLower.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCInstLower.cpp - Convert Cpu0 MachineInstr to MCInst ---------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains code to lower Cpu0 MachineInstrs to their corresponding</span>
<span class="c1">// MCInst records.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0MCInstLower.h&quot;</span>
<span class="cp">#include &quot;Cpu0AsmPrinter.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstr.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCContext.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInst.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/Mangler.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">Cpu0MCInstLower</span><span class="p">(</span><span class="n">Cpu0AsmPrinter</span> <span class="o">&amp;</span><span class="n">asmprinter</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">AsmPrinter</span><span class="p">(</span><span class="n">asmprinter</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">Mangler</span> <span class="o">*</span><span class="n">M</span><span class="p">,</span> <span class="n">MCContext</span><span class="o">*</span> <span class="n">C</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Mang</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span>
  <span class="n">Ctx</span> <span class="o">=</span> <span class="n">C</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                                              <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">Kind</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Symbol</span><span class="p">;</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span>                   <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Invalid target flag!&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="nl">MO_GlobalAddress:</span>
    <span class="n">Symbol</span> <span class="o">=</span> <span class="n">Mang</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getGlobal</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">default</span><span class="o">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;&lt;unknown operand type&gt;&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">MCSymbolRefExpr</span> <span class="o">*</span><span class="n">MCSym</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Kind</span><span class="p">,</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Offset</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateExpr</span><span class="p">(</span><span class="n">MCSym</span><span class="p">);</span>

  <span class="c1">// Assume offset is never negative.</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">MCConstantExpr</span> <span class="o">*</span><span class="n">OffsetExpr</span> <span class="o">=</span>  <span class="n">MCConstantExpr</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">Offset</span><span class="p">,</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCBinaryExpr</span> <span class="o">*</span><span class="n">AddExpr</span> <span class="o">=</span> <span class="n">MCBinaryExpr</span><span class="o">::</span><span class="n">CreateAdd</span><span class="p">(</span><span class="n">MCSym</span><span class="p">,</span> <span class="n">OffsetExpr</span><span class="p">,</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateExpr</span><span class="p">(</span><span class="n">AddExpr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span><span class="o">&amp;</span> <span class="n">MO</span><span class="p">,</span>
                                        <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineOperandType</span> <span class="n">MOTy</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">();</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span> <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;unknown operand type&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="nl">MO_Register:</span>
    <span class="c1">// Ignore all implicit register operands.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isImplicit</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getReg</span><span class="p">());</span>
  <span class="k">case</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="nl">MO_Immediate:</span>
    <span class="k">return</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="nl">MO_RegisterMask:</span>
    <span class="k">break</span><span class="p">;</span>
 <span class="p">}</span>

  <span class="k">return</span> <span class="n">MCOperand</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">Lower</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">OutMI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">OutMI</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">());</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">MCOperand</span> <span class="n">MCOp</span> <span class="o">=</span> <span class="n">LowerOperand</span><span class="p">(</span><span class="n">MO</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">MCOp</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span>
      <span class="n">OutMI</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOp</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/MCTargetDesc/Cpu0BaseInfo.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0BaseInfo.h - Top level definitions for CPU0 MC ------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains small standalone helper functions and enum definitions for</span>
<span class="c1">// the Cpu0 target useful for the compiler back-end and the MC libraries.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#ifndef CPU0BASEINFO_H</span>
<span class="cp">#define CPU0BASEINFO_H</span>

<span class="cp">#include &quot;Cpu0FixupKinds.h&quot;</span>
<span class="cp">#include &quot;Cpu0MCTargetDesc.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/DataTypes.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="c1">/// Cpu0II - This namespace holds all of the target specific flags that</span>
<span class="c1">/// instruction info tracks.</span>
<span class="c1">///</span>
<span class="k">namespace</span> <span class="n">Cpu0II</span> <span class="p">{</span>
  <span class="c1">/// Target Operand Flag enum.</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="c1">//===------------------------------------------------------------------===//</span>
    <span class="c1">// Instruction encodings.  These are the standard/most common forms for</span>
    <span class="c1">// Cpu0 instructions.</span>
    <span class="c1">//</span>

    <span class="c1">// Pseudo - This represents an instruction that is a pseudo instruction</span>
    <span class="c1">// or one that has not been implemented yet.  It is illegal to code generate</span>
    <span class="c1">// it, but tolerated for intermediate implementation stages.</span>
    <span class="n">Pseudo</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

    <span class="c1">/// FrmR - This form is for instructions of the format R.</span>
    <span class="n">FrmR</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="c1">/// FrmI - This form is for instructions of the format I.</span>
    <span class="n">FrmI</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="c1">/// FrmJ - This form is for instructions of the format J.</span>
    <span class="n">FrmJ</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="c1">/// FrmOther - This form is for instructions that have no specific format.</span>
    <span class="n">FrmOther</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>

    <span class="n">FormMask</span> <span class="o">=</span> <span class="mi">15</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">/// getCpu0RegisterNumbering - Given the enum value for some register,</span>
<span class="c1">/// return the number that it corresponds to.</span>
<span class="kr">inline</span> <span class="k">static</span> <span class="kt">unsigned</span> <span class="n">getCpu0RegisterNumbering</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegEnum</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">RegEnum</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">ZERO:</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">AT:</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">V0:</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">V1:</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">A0:</span>
    <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">A1:</span>
    <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">T9:</span>
    <span class="k">return</span> <span class="mi">6</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">S0:</span>
    <span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">S1:</span>
    <span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">S2:</span>
    <span class="k">return</span> <span class="mi">9</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">GP:</span>
    <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">FP:</span>
    <span class="k">return</span> <span class="mi">11</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">SW:</span>
    <span class="k">return</span> <span class="mi">12</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">SP:</span>
    <span class="k">return</span> <span class="mi">13</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">LR:</span>
    <span class="k">return</span> <span class="mi">14</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">PC:</span>
    <span class="k">return</span> <span class="mi">15</span><span class="p">;</span>
  <span class="k">default</span><span class="o">:</span> <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unknown register number!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/MCTargetDesc/Cpu0FixupKinds.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0FixupKinds.h - Cpu0 Specific Fixup Entries ----------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLVM_CPU0_CPU0FIXUPKINDS_H</span>
<span class="cp">#define LLVM_CPU0_CPU0FIXUPKINDS_H</span>

<span class="cp">#include &quot;llvm/MC/MCFixup.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Cpu0</span> <span class="p">{</span>
  <span class="c1">// Although most of the current fixup types reflect a unique relocation</span>
  <span class="c1">// one can have multiple fixup types for a given relocation and thus need</span>
  <span class="c1">// to be uniquely named.</span>
  <span class="c1">//</span>
  <span class="c1">// This table *must* be in the save order of</span>
  <span class="c1">// MCFixupKindInfo Infos[Cpu0::NumTargetFixupKinds]</span>
  <span class="c1">// in Cpu0AsmBackend.cpp.</span>
  <span class="c1">//</span>
  <span class="k">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
    <span class="c1">// Branch fixups resulting in R_CPU0_16.</span>
    <span class="n">fixup_Cpu0_16</span> <span class="o">=</span> <span class="n">FirstTargetFixupKind</span><span class="p">,</span>

    <span class="c1">// Marker</span>
    <span class="n">LastTargetFixupKind</span><span class="p">,</span>
    <span class="n">NumTargetFixupKinds</span> <span class="o">=</span> <span class="n">LastTargetFixupKind</span> <span class="o">-</span> <span class="n">FirstTargetFixupKind</span>
  <span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace Cpu0</span>
<span class="p">}</span> <span class="c1">// namespace llvm</span>


<span class="cp">#endif </span><span class="c1">// LLVM_CPU0_CPU0FIXUPKINDS_H</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/MCTargetDesc/Cpu0MCAsmInfo.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCAsmInfo.h - Cpu0 Asm Info ------------------------*- C++ -*--===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the declaration of the Cpu0MCAsmInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0TARGETASMINFO_H</span>
<span class="cp">#define CPU0TARGETASMINFO_H</span>

<span class="cp">#include &quot;llvm/MC/MCAsmInfo.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">StringRef</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">Target</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Cpu0MCAsmInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCAsmInfo</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Cpu0MCAsmInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">);</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace llvm</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/MCTargetDesc/Cpu0MCAsmInfo.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCAsmInfo.cpp - Cpu0 Asm Properties ---------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the declarations of the Cpu0MCAsmInfo properties.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0MCAsmInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/Triple.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">Cpu0MCAsmInfo</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">Cpu0MCAsmInfo</span><span class="o">::</span><span class="n">Cpu0MCAsmInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Triple</span> <span class="n">TheTriple</span><span class="p">(</span><span class="n">TT</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">TheTriple</span><span class="p">.</span><span class="n">getArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="p">))</span>
    <span class="n">IsLittleEndian</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

  <span class="n">AlignmentIsInBytes</span>          <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="n">Data16bitsDirective</span>         <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.2byte</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">Data32bitsDirective</span>         <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.4byte</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">Data64bitsDirective</span>         <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.8byte</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">PrivateGlobalPrefix</span>         <span class="o">=</span> <span class="s">&quot;$&quot;</span><span class="p">;</span>
  <span class="n">CommentString</span>               <span class="o">=</span> <span class="s">&quot;#&quot;</span><span class="p">;</span>
  <span class="n">ZeroDirective</span>               <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.space</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">GPRel32Directive</span>            <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.gpword</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">GPRel64Directive</span>            <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.gpdword</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">WeakRefDirective</span>            <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.weak</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>

  <span class="n">SupportsDebugInformation</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="n">ExceptionsType</span> <span class="o">=</span> <span class="n">ExceptionHandling</span><span class="o">::</span><span class="n">DwarfCFI</span><span class="p">;</span>
  <span class="n">HasLEB128</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="n">DwarfRegNumForCFI</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Finally, add code in Cpu0MCTargetDesc.cpp to register Cpu0InstPrinter as
follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/MCTargetDesc/Cpu0MCTargetDesc.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ParseCpu0Triple</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Cpu0ArchFeature</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">DashPosition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">StringRef</span> <span class="n">TheTriple</span><span class="p">;</span>

  <span class="c1">// Let&#39;s see if there is a dash, like cpu0-unknown-linux.</span>
  <span class="n">DashPosition</span> <span class="o">=</span> <span class="n">TT</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DashPosition</span> <span class="o">==</span> <span class="n">StringRef</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// No dash, we check the string size.</span>
    <span class="n">TheTriple</span> <span class="o">=</span> <span class="n">TT</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// We are only interested in substring before dash.</span>
    <span class="n">TheTriple</span> <span class="o">=</span> <span class="n">TT</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">DashPosition</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">TheTriple</span> <span class="o">==</span> <span class="s">&quot;cpu0&quot;</span> <span class="o">||</span> <span class="n">TheTriple</span> <span class="o">==</span> <span class="s">&quot;cpu0el&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CPU</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">CPU</span> <span class="o">==</span> <span class="s">&quot;cpu032&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Cpu0ArchFeature</span> <span class="o">=</span> <span class="s">&quot;+cpu032&quot;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Cpu0ArchFeature</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCInstrInfo</span> <span class="o">*</span><span class="n">createCpu0MCInstrInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MCInstrInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCInstrInfo</span><span class="p">();</span>
  <span class="n">InitCpu0MCInstrInfo</span><span class="p">(</span><span class="n">X</span><span class="p">);</span> <span class="c1">// defined in Cpu0GenInstrInfo.inc</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCRegisterInfo</span> <span class="o">*</span><span class="n">createCpu0MCRegisterInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCRegisterInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCRegisterInfo</span><span class="p">();</span>
  <span class="n">InitCpu0MCRegisterInfo</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">);</span> <span class="c1">// defined in Cpu0GenRegisterInfo.inc</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCSubtargetInfo</span> <span class="o">*</span><span class="n">createCpu0MCSubtargetInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span>
                                                  <span class="n">StringRef</span> <span class="n">FS</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ArchFS</span> <span class="o">=</span> <span class="n">ParseCpu0Triple</span><span class="p">(</span><span class="n">TT</span><span class="p">,</span><span class="n">CPU</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FS</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ArchFS</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
      <span class="n">ArchFS</span> <span class="o">=</span> <span class="n">ArchFS</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="n">FS</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="k">else</span>
      <span class="n">ArchFS</span> <span class="o">=</span> <span class="n">FS</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">MCSubtargetInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCSubtargetInfo</span><span class="p">();</span>
  <span class="n">InitCpu0MCSubtargetInfo</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">ArchFS</span><span class="p">);</span> <span class="c1">// defined in Cpu0GenSubtargetInfo.inc</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">createCpu0MCAsmInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">MAI</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cpu0MCAsmInfo</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">);</span>

  <span class="n">MachineLocation</span> <span class="n">Dst</span><span class="p">(</span><span class="n">MachineLocation</span><span class="o">::</span><span class="n">VirtualFP</span><span class="p">);</span>
  <span class="n">MachineLocation</span> <span class="n">Src</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">MAI</span><span class="o">-&gt;</span><span class="n">addInitialFrameState</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Dst</span><span class="p">,</span> <span class="n">Src</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">MAI</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCCodeGenInfo</span> <span class="o">*</span><span class="n">createCpu0MCCodeGenInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span>
                                              <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                                              <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCCodeGenInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCCodeGenInfo</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CM</span> <span class="o">==</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">JITDefault</span><span class="p">)</span>
    <span class="n">RM</span> <span class="o">=</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Static</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">RM</span> <span class="o">==</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Default</span><span class="p">)</span>
    <span class="n">RM</span> <span class="o">=</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">PIC_</span><span class="p">;</span>
  <span class="n">X</span><span class="o">-&gt;</span><span class="n">InitMCCodeGenInfo</span><span class="p">(</span><span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">);</span> <span class="c1">// defined in lib/MC/MCCodeGenInfo.cpp</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCInstPrinter</span> <span class="o">*</span><span class="n">createCpu0MCInstPrinter</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">SyntaxVariant</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCAsmInfo</span> <span class="o">&amp;</span><span class="n">MAI</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MII</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0InstPrinter</span><span class="p">(</span><span class="n">MAI</span><span class="p">,</span> <span class="n">MII</span><span class="p">,</span> <span class="n">MRI</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0TargetMC</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Register the MC asm info.</span>
  <span class="n">RegisterMCAsmInfoFn</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createCpu0MCAsmInfo</span><span class="p">);</span>
  <span class="n">RegisterMCAsmInfoFn</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createCpu0MCAsmInfo</span><span class="p">);</span>

  <span class="c1">// Register the MC codegen info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCCodeGenInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                        <span class="n">createCpu0MCCodeGenInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCCodeGenInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                        <span class="n">createCpu0MCCodeGenInfo</span><span class="p">);</span>
  <span class="c1">// Register the MC instruction info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstrInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createCpu0MCInstrInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstrInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createCpu0MCInstrInfo</span><span class="p">);</span>

  <span class="c1">// Register the MC register info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCRegInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createCpu0MCRegisterInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCRegInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createCpu0MCRegisterInfo</span><span class="p">);</span>

  <span class="c1">// Register the MC subtarget info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCSubtargetInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                          <span class="n">createCpu0MCSubtargetInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCSubtargetInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                          <span class="n">createCpu0MCSubtargetInfo</span><span class="p">);</span>
  <span class="c1">// Register the MCInstPrinter.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstPrinter</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                        <span class="n">createCpu0MCInstPrinter</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstPrinter</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                        <span class="n">createCpu0MCInstPrinter</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Now, it&#8217;s time to work with AsmPrinter. According section
&#8220;section Target Registration&#8221; <a class="footnote-reference" href="#id6" id="id2">[2]</a>, we can register our AsmPrinter when we need it
as the following function of LLVMInitializeCpu0AsmPrinter(),</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0AsmPrinter.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0AsmPrinter.h - Cpu0 LLVM Assembly Printer ----------*- C++ -*--===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// Cpu0 Assembly printer class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0ASMPRINTER_H</span>
<span class="cp">#define CPU0ASMPRINTER_H</span>

<span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="cp">#include &quot;Cpu0MCInstLower.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/AsmPrinter.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Compiler.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">MCStreamer</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">MachineInstr</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">MachineBasicBlock</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Module</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">raw_ostream</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">LLVM_LIBRARY_VISIBILITY</span> <span class="n">Cpu0AsmPrinter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AsmPrinter</span> <span class="p">{</span>

  <span class="kt">void</span> <span class="n">EmitInstrWithMacroNoAT</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>

  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">*</span><span class="n">Subtarget</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span><span class="p">;</span>
  <span class="n">Cpu0MCInstLower</span> <span class="n">MCInstLowering</span><span class="p">;</span>

  <span class="k">explicit</span> <span class="n">Cpu0AsmPrinter</span><span class="p">(</span><span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>  <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">Streamer</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">AsmPrinter</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="n">Streamer</span><span class="p">),</span> <span class="n">MCInstLowering</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Subtarget</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getPassName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Cpu0 Assembly Printer&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">);</span>

<span class="c1">//- EmitInstruction() must exists or will have run time error.</span>
  <span class="kt">void</span> <span class="n">EmitInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">printSavedRegsBitmask</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">printHex32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Value</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">emitFrameDirective</span><span class="p">();</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getCurrentABIString</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">EmitFunctionEntryLabel</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">EmitFunctionBodyStart</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">EmitFunctionBodyEnd</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">EmitStartOfAsmFile</span><span class="p">(</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="n">MachineLocation</span> <span class="n">getDebugValueLocation</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">PrintDebugValueComment</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0AsmPrinter.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0AsmPrinter.cpp - Cpu0 LLVM Assembly Printer -------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains a printer that converts from our internal representation</span>
<span class="c1">// of machine-dependent LLVM code to GAS-format CPU0 assembly language.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-asm-printer&quot;</span>
<span class="cp">#include &quot;Cpu0AsmPrinter.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;InstPrinter/Cpu0InstPrinter.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/SmallString.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/StringExtras.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/Twine.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/BasicBlock.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Instructions.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineConstantPool.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstr.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineMemOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCStreamer.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCAsmInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInst.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSymbol.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/Mangler.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetLoweringObjectFile.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetOptions.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">AsmPrinter</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MF</span><span class="p">);</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//- EmitInstruction() must exists or will have run time error.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">isDebugValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">Str</span><span class="p">;</span>
    <span class="n">raw_svector_ostream</span> <span class="n">OS</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span>

    <span class="n">PrintDebugValueComment</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">OS</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">MCInst</span> <span class="n">TmpInst0</span><span class="p">;</span>
  <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">Lower</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">TmpInst0</span><span class="p">);</span>
  <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">TmpInst0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//  Cpu0 Asm Directives</span>
<span class="c1">//</span>
<span class="c1">//  -- Frame directive &quot;frame Stackpointer, Stacksize, RARegister&quot;</span>
<span class="c1">//  Describe the stack frame.</span>
<span class="c1">//</span>
<span class="c1">//  -- Mask directives &quot;(f)mask  bitmask, offset&quot;</span>
<span class="c1">//  Tells the assembler which registers are saved and where.</span>
<span class="c1">//  bitmask - contain a little endian bitset indicating which registers are</span>
<span class="c1">//            saved on function prologue (e.g. with a 0x80000000 mask, the</span>
<span class="c1">//            assembler knows the register 31 (RA) is saved at prologue.</span>
<span class="c1">//  offset  - the position before stack pointer subtraction indicating where</span>
<span class="c1">//            the first saved register on prologue is located. (e.g. with a</span>
<span class="c1">//</span>
<span class="c1">//  Consider the following function prologue:</span>
<span class="c1">//</span>
<span class="c1">//    .frame  $fp,48,$ra</span>
<span class="c1">//    .mask   0xc0000000,-8</span>
<span class="c1">//       addiu $sp, $sp, -48</span>
<span class="c1">//       st $ra, 40($sp)</span>
<span class="c1">//       st $fp, 36($sp)</span>
<span class="c1">//</span>
<span class="c1">//    With a 0xc0000000 mask, the assembler knows the register 31 (RA) and</span>
<span class="c1">//    30 (FP) are saved at prologue. As the save order on prologue is from</span>
<span class="c1">//    left to right, RA is saved first. A -8 offset means that after the</span>
<span class="c1">//    stack pointer subtration, the first register in the mask (RA) will be</span>
<span class="c1">//    saved at address 48-8=40.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Mask directives</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//	.frame	$sp,8,$lr</span>
<span class="c1">//-&gt;	.mask 	0x00000000,0</span>
<span class="c1">//	.set	noreorder</span>
<span class="c1">//	.set	nomacro</span>

<span class="c1">// Create a bitmask with all callee saved registers for CPU or Floating Point</span>
<span class="c1">// registers. For CPU registers consider RA, GP and FP for saving if necessary.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">printSavedRegsBitmask</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// CPU and FPU Saved Registers Bitmasks</span>
  <span class="kt">unsigned</span> <span class="n">CPUBitmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">CPUTopSavedRegOff</span><span class="p">;</span>

  <span class="c1">// Set the CPU and FPU Bitmasks</span>
  <span class="k">const</span> <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">-&gt;</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">();</span>
  <span class="c1">// size of stack area to which FP callee-saved regs are saved.</span>
  <span class="kt">unsigned</span> <span class="n">CPURegSize</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">getSize</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="c1">// Set CPU Bitmask.</span>
  <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getReg</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="n">RegNum</span> <span class="o">=</span> <span class="n">getCpu0RegisterNumbering</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
    <span class="n">CPUBitmask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RegNum</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">CPUTopSavedRegOff</span> <span class="o">=</span> <span class="n">CPUBitmask</span> <span class="o">?</span> <span class="o">-</span><span class="n">CPURegSize</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Print CPUBitmask</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.mask </span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span> <span class="n">printHex32</span><span class="p">(</span><span class="n">CPUBitmask</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">CPUTopSavedRegOff</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Print a 32 bit hex number with all numbers.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">printHex32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Value</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;0x&quot;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
    <span class="n">O</span><span class="p">.</span><span class="n">write_hex</span><span class="p">((</span><span class="n">Value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0xF</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Frame and Set directives</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//-&gt;	.frame	$sp,8,$lr</span>
<span class="c1">//	.mask 	0x00000000,0</span>
<span class="c1">//	.set	noreorder</span>
<span class="c1">//	.set	nomacro</span>
<span class="c1">/// Frame Directive</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">emitFrameDirective</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">&amp;</span><span class="n">RI</span> <span class="o">=</span> <span class="o">*</span><span class="n">TM</span><span class="p">.</span><span class="n">getRegisterInfo</span><span class="p">();</span>

  <span class="kt">unsigned</span> <span class="n">stackReg</span>  <span class="o">=</span> <span class="n">RI</span><span class="p">.</span><span class="n">getFrameRegister</span><span class="p">(</span><span class="o">*</span><span class="n">MF</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">returnReg</span> <span class="o">=</span> <span class="n">RI</span><span class="p">.</span><span class="n">getRARegister</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">stackSize</span> <span class="o">=</span> <span class="n">MF</span><span class="o">-&gt;</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.frame</span><span class="se">\t</span><span class="s">$&quot;</span> <span class="o">+</span>
           <span class="n">StringRef</span><span class="p">(</span><span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">stackReg</span><span class="p">)).</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span>
           <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">stackSize</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;,$&quot;</span> <span class="o">+</span>
           <span class="n">StringRef</span><span class="p">(</span><span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">returnReg</span><span class="p">)).</span><span class="n">lower</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">/// Emit Set directives.</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">getCurrentABIString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">getTargetABI</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0Subtarget</span><span class="o">::</span><span class="nl">O32:</span>  <span class="k">return</span> <span class="s">&quot;abi32&quot;</span><span class="p">;</span>
  <span class="k">default</span><span class="o">:</span> <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unknown Cpu0 ABI&quot;</span><span class="p">);;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//		.type	main,@function</span>
<span class="c1">//-&gt;		.ent	main                    # @main</span>
<span class="c1">//	main:</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitFunctionEntryLabel</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.ent</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">CurrentFnSym</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()));</span>
  <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitLabel</span><span class="p">(</span><span class="n">CurrentFnSym</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">//	.frame	$sp,8,$pc</span>
<span class="c1">//	.mask 	0x00000000,0</span>
<span class="c1">//-&gt;	.set	noreorder</span>
<span class="c1">//-&gt;	.set	nomacro</span>
<span class="c1">/// EmitFunctionBodyStart - Targets can override this to emit stuff before</span>
<span class="c1">/// the first basic block in the function.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitFunctionBodyStart</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">Initialize</span><span class="p">(</span><span class="n">Mang</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">());</span>

  <span class="n">emitFrameDirective</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">Str</span><span class="p">;</span>
    <span class="n">raw_svector_ostream</span> <span class="n">OS</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span>
    <span class="n">printSavedRegsBitmask</span><span class="p">(</span><span class="n">OS</span><span class="p">);</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">OS</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>

    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">noreorder&quot;</span><span class="p">));</span>

    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">nomacro&quot;</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//-&gt;	.set	macro</span>
<span class="c1">//-&gt;	.set	reorder</span>
<span class="c1">//-&gt;	.end	main</span>
<span class="c1">/// EmitFunctionBodyEnd - Targets can override this to emit stuff after</span>
<span class="c1">/// the last basic block in the function.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitFunctionBodyEnd</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// There are instruction for this macros, but they must</span>
  <span class="c1">// always be at the function end, and we can&#39;t emit and</span>
  <span class="c1">// break with BB logic.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">macro&quot;</span><span class="p">));</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">reorder&quot;</span><span class="p">));</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.end</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">CurrentFnSym</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//	.section .mdebug.abi32</span>
<span class="c1">//	.previous</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitStartOfAsmFile</span><span class="p">(</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// FIXME: Use SwitchSection.</span>

  <span class="c1">// Tell the assembler which ABI we are using</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.section .mdebug.&quot;</span> <span class="o">+</span>
                            <span class="n">Twine</span><span class="p">(</span><span class="n">getCurrentABIString</span><span class="p">()));</span>

  <span class="c1">// return to previous section</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.previous&quot;</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">MachineLocation</span>
<span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">getDebugValueLocation</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Handles frame addresses emitted in Cpu0InstrInfo::emitFrameIndexDebugValue.</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid no. of machine operands!&quot;</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">isImm</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
         <span class="s">&quot;Unexpected MachineOperand types&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getReg</span><span class="p">(),</span>
                         <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">getImm</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">PrintDebugValueComment</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
                                           <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// TODO: implement</span>
  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;PrintDebugValueComment()&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Force static initialization.</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0AsmPrinter</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">RegisterAsmPrinter</span><span class="o">&lt;</span><span class="n">Cpu0AsmPrinter</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">);</span>
  <span class="n">RegisterAsmPrinter</span><span class="o">&lt;</span><span class="n">Cpu0AsmPrinter</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The dynamic register mechanism is a good idea, right.</p>
<p>Except add the new .cpp files to CMakeLists.txt, please remember to add
subdirectory InstPrinter, enable asmprinter, add libraries AsmPrinter and
Cpu0AsmPrinter to LLVMBuild.txt as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/LLVMBuild.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  LLVMBuild.txt</span>
<span class="p">[</span><span class="n">common</span><span class="p">]</span>
<span class="n">subdirectories</span> <span class="o">=</span> <span class="n">InstPrinter</span> <span class="n">MCTargetDesc</span> <span class="n">TargetInfo</span>

<span class="p">[</span><span class="n">component_0</span><span class="p">]</span>
<span class="p">...</span>
<span class="cp"># Please enable asmprinter</span>
<span class="n">has_asmprinter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">...</span>

<span class="p">[</span><span class="n">component_1</span><span class="p">]</span>
<span class="cp"># Add AsmPrinter Cpu0AsmPrinter</span>
<span class="n">required_libraries</span> <span class="o">=</span> <span class="n">AsmPrinter</span> <span class="n">CodeGen</span> <span class="n">Core</span> <span class="n">MC</span> <span class="n">Cpu0AsmPrinter</span> <span class="n">Cpu0Desc</span>
                     <span class="n">Cpu0Info</span> <span class="n">SelectionDAG</span> <span class="n">Support</span> <span class="n">Target</span>
</pre></div>
</div>
<p>Now, run Chapter3_3/Cpu0 for AsmPrinter support, will get error message as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc -o
ch3.cpu0.s
/Users/Jonathan/llvm/test/cmake_debug_build/bin/Debug/llc: target does not
support generation of this file <span class="nb">type</span>!
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">llc</span></tt> fails to compile IR code into machine code since we didn&#8217;t implement
class Cpu0DAGToDAGISel. Before the implementation, we will introduce the LLVM
Code Generation Sequence, DAG, and LLVM instruction selection in next 3
sections.</p>
</div>
<div class="section" id="llvm-code-generation-sequence">
<h2>LLVM Code Generation Sequence<a class="headerlink" href="#llvm-code-generation-sequence" title="Permalink to this headline">¶</a></h2>
<p>Following diagram came from tricore_llvm.pdf.</p>
<div class="figure align-center" id="backendstructure-f5">
<img alt="_images/5.png" src="_images/5.png" />
<p class="caption">Figure 5: tricore_llvm.pdf: Code generation sequence. On the path from LLVM code to
assembly code, numerous passes are run through and several data structures
are used to represent the intermediate results.</p>
</div>
<p>LLVM is a Static Single Assignment (SSA) based representation.
LLVM provides an infinite virtual registers which can hold values of primitive
type (integral, floating point, or pointer values).
So, every operand can save in different virtual register in llvm SSA
representation.
Comment is “;” in llvm representation.
Following is the llvm SSA instructions.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">store</span> <span class="n">i32</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>  <span class="p">;</span> <span class="n">store</span> <span class="n">i32</span> <span class="n">type</span> <span class="n">of</span> <span class="mi">0</span> <span class="n">to</span> <span class="k">virtual</span> <span class="k">register</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span> <span class="n">is</span>
            <span class="p">;</span>  <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span> <span class="p">;</span> <span class="n">store</span> <span class="o">%</span><span class="n">b</span> <span class="n">contents</span> <span class="n">to</span> <span class="o">%</span><span class="n">c</span> <span class="n">point</span> <span class="n">to</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span> <span class="n">isi32</span> <span class="n">type</span> <span class="k">virtual</span>
            <span class="p">;</span>  <span class="k">register</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span> <span class="n">is</span> <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span><span class="p">.</span>
<span class="o">%</span><span class="n">a1</span> <span class="o">=</span> <span class="n">load</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>    <span class="p">;</span> <span class="n">load</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">value</span> <span class="n">where</span> <span class="o">%</span><span class="n">a</span> <span class="n">point</span> <span class="n">to</span> <span class="n">and</span> <span class="n">assign</span> <span class="n">the</span>
            <span class="p">;</span>  <span class="n">memory</span> <span class="n">value</span> <span class="n">to</span> <span class="o">%</span><span class="n">a1</span>
<span class="o">%</span><span class="n">a3</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a2</span><span class="p">,</span> <span class="mi">1</span>  <span class="p">;</span> <span class="n">add</span> <span class="o">%</span><span class="n">a2</span> <span class="n">and</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">save</span> <span class="n">to</span> <span class="o">%</span><span class="n">a3</span>
</pre></div>
</div>
<p>We explain the code generation process as below.
If you don&#8217;t feel comfortable, please check tricore_llvm.pdf section 4.2 first.
You can  read “The LLVM Target-Independent Code Generator” from <a class="footnote-reference" href="#id7" id="id3">[3]</a>
and “LLVM Language Reference Manual” from <a class="footnote-reference" href="#id8" id="id4">[4]</a>
before go ahead, but we think read section
4.2 of tricore_llvm.pdf is enough.
We suggest you read the web site documents as above only when you are still not
quite understand, even though you have read the articles of this section and
next 2 sections for DAG and Instruction Selection.</p>
<ol class="arabic simple">
<li>Instruction Selection</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// In this stage, transfer the llvm opcode into machine opcode, but the operand</span>
<span class="c1">//  still is llvm virtual operand.</span>
    <span class="n">store</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span> <span class="c1">// store 0 of i16 type to where virtual register %a</span>
               <span class="c1">//  point to</span>
<span class="o">=&gt;</span>  <span class="n">addiu</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>Scheduling and Formation</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// In this stage, reorder the instructions sequence for optimization in</span>
<span class="c1">//  instructions cycle or in register pressure.</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span> <span class="c1">// st %a to *(%b+5)</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span>

<span class="c1">// Transfer above instructions order as follows. In RISC like Mips the ld %c use</span>
<span class="c1">//  the previous instruction st %c, must wait more than 1</span>
<span class="c1">// cycles. Meaning the ld cannot follow st immediately.</span>
<span class="o">=&gt;</span>  <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
<span class="c1">// If without reorder instructions, a instruction nop which do nothing must be</span>
<span class="c1">//  filled, contribute one instruction cycle more than optimization. (Actually,</span>
<span class="c1">//  Mips is scheduled with hardware dynamically and will insert nop between st</span>
<span class="c1">//  and ld instructions if compiler didn&#39;t insert nop.)</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="n">nop</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>

<span class="c1">// Minimum register pressure</span>
<span class="c1">//  Suppose %c is alive after the instructions basic block (meaning %c will be</span>
<span class="c1">//  used after the basic block), %a and %b are not alive after that.</span>
<span class="c1">// The following no reorder version need 3 registers at least</span>
    <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>

<span class="c1">// The reorder version need 2 registers only (by allocate %a and %b in the same</span>
<span class="c1">//  register)</span>
<span class="o">=&gt;</span> <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>
</pre></div>
</div>
<ol class="arabic" start="3">
<li><p class="first">SSA-based Machine Code Optimization</p>
<blockquote>
<div><p>For example, common expression remove, shown in next section DAG.</p>
</div></blockquote>
</li>
<li><p class="first">Register Allocation</p>
<blockquote>
<div><p>Allocate real register for virtual register.</p>
</div></blockquote>
</li>
<li><p class="first">Prologue/Epilogue Code Insertion</p>
<blockquote>
<div><p>Explain in section Add Prologue/Epilogue functions</p>
</div></blockquote>
</li>
<li><p class="first">Late Machine Code Optimizations</p>
<blockquote>
<div><p>Any “last-minute” peephole optimizations of the final machine code can be
applied during this phase.
For example, replace x = x * 2 by x = x &lt; 1 for integer operand.</p>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>Code Emission</dt>
<dd><p class="first last">Finally, the completed machine code is emitted. For static compilation,
the end result is an assembly code file; for JIT compilation, the opcodes
of the machine instructions are written into memory.</p>
</dd>
</dl>
</li>
</ol>
<p>The llvm code generation sequence also can be obtained by
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></tt> as the following. The first 4 code generation
sequences from <a class="pageref" href="#backendstructure-f5">Figure  5</a> are in the
<strong>&#8216;DAG-&gt;DAG Pattern Instruction Selection&#8217;</strong> of the <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></tt>
displayed. The order of Peephole Optimizations and Prologue/Epilogue Insertion
is inconsistent in them (please check the * in the following).
No need to bother since the the LLVM is under development and changed all the
time.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-200:InputFiles Jonathan<span class="nv">$ </span>llc --help-hidden
OVERVIEW: llvm system compiler

USAGE: llc <span class="o">[</span>options<span class="o">]</span> &lt;input bitcode&gt;

OPTIONS:
...
  -debug-pass                             - Print PassManager debugging <span class="nv">information</span>
    <span class="o">=</span>None                                 -   disable debug <span class="nv">output</span>
    <span class="o">=</span>Arguments                            -   print pass arguments to pass to <span class="s1">&#39;opt&#39;</span>
    <span class="o">=</span>Structure                            -   print pass structure before run<span class="o">()</span>
    <span class="o">=</span>Executions                           -   print pass name before it is <span class="nv">executed</span>
    <span class="o">=</span>Details                              -   print pass details when it is executed

118-165-79-200:InputFiles Jonathan<span class="nv">$ </span>llc -march<span class="o">=</span>mips -debug-pass<span class="o">=</span>Structure ch3.bc
...
Target Library Information
Target Transform Info
Data Layout
Target Pass Configuration
No Alias Analysis <span class="o">(</span>always returns <span class="s1">&#39;may&#39;</span> <span class="nb">alias</span><span class="o">)</span>
Type-Based Alias Analysis
Basic Alias Analysis <span class="o">(</span>stateless AA impl<span class="o">)</span>
Create Garbage Collector Module Metadata
Machine Module Information
Machine Branch Probability Analysis
  ModulePass Manager
    FunctionPass Manager
      Preliminary module verification
      Dominator Tree Construction
      Module Verifier
      Natural Loop Information
      Loop Pass Manager
        Canonicalize natural loops
      Scalar Evolution Analysis
      Loop Pass Manager
        Canonicalize natural loops
        Induction Variable Users
        Loop Strength Reduction
      Lower Garbage Collection Instructions
      Remove unreachable blocks from the CFG
      Exception handling preparation
      Optimize <span class="k">for </span>code generation
      Insert stack protectors
      Preliminary module verification
      Dominator Tree Construction
      Module Verifier
      Machine Function Analysis
      Natural Loop Information
      Branch Probability Analysis
    * MIPS DAG-&gt;DAG Pattern Instruction Selection
      Expand ISel Pseudo-instructions
      Tail Duplication
      Optimize machine instruction PHIs
      MachineDominator Tree Construction
      Slot index numbering
      Merge disjoint stack slots
      Local Stack Slot Allocation
      Remove dead machine instructions
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Loop Invariant Code Motion
      Machine Common Subexpression Elimination
      Machine code sinking
    * Peephole Optimizations
      Process Implicit Definitions
      Remove unreachable machine basic blocks
      Live Variable Analysis
      Eliminate PHI nodes <span class="k">for </span>register allocation
      Two-Address instruction pass
      Slot index numbering
      Live Interval Analysis
      Debug Variable Analysis
      Simple Register Coalescing
      Live Stack Slot Analysis
      Calculate spill weights
      Virtual Register Map
      Live Register Matrix
      Bundle Machine CFG Edges
      Spill Code Placement Analysis
      Greedy Register Allocator
      Virtual Register Rewriter
      Stack Slot Coloring
      Machine Loop Invariant Code Motion
    * Prologue/Epilogue Insertion &amp; Frame Finalization
      Control Flow Optimizer
      Tail Duplication
      Machine Copy Propagation Pass
      Post-RA pseudo instruction expansion pass
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Post RA top-down list latency scheduler
      Analyze Machine Code For Garbage Collection
      Machine Block Frequency Analysis
      Branch Probability Basic Block Placement
      Mips Delay Slot Filler
      Mips Long Branch
      MachineDominator Tree Construction
      Machine Natural Loop Construction
    * Mips Assembly Printer
      Delete Garbage Collector Information
</pre></div>
</div>
</div>
<div class="section" id="dag-directed-acyclic-graph">
<h2>DAG (Directed Acyclic Graph)<a class="headerlink" href="#dag-directed-acyclic-graph" title="Permalink to this headline">¶</a></h2>
<p>Many important techniques for local optimization begin by transforming a basic
block into DAG. For example, the basic block code and it&#8217;s corresponding DAG as
<a class="pageref" href="#backendstructure-f6">Figure  6</a>.</p>
<div class="figure align-center" id="backendstructure-f6">
<img alt="_images/6.png" src="_images/6.png" />
<p class="caption">Figure 6: DAG example</p>
</div>
<p>If b is not live on exit from the block, then we can do common expression
remove to get the following code.</p>
<div class="highlight-c++"><pre>a = b + c
d = a – d
c = d + c</pre>
</div>
<p>As you can imagine, the common expression remove can apply in IR or machine
code.</p>
<p>DAG like a tree which opcode is the node and operand (register and
const/immediate/offset) is leaf.
It can also be represented by list as prefix order in tree.
For example, (+ b, c), (+ b, 1) is IR DAG representation.</p>
</div>
<div class="section" id="instruction-selection">
<h2>Instruction Selection<a class="headerlink" href="#instruction-selection" title="Permalink to this headline">¶</a></h2>
<p>In back end, we need to translate IR code into machine code at Instruction
Selection Process as <a class="pageref" href="#backendstructure-f7">Figure  7</a>.</p>
<div class="figure align-center" id="backendstructure-f7">
<img alt="_images/7.png" src="_images/7.png" />
<p class="caption">Figure 7: IR and it&#8217;s corresponding machine instruction</p>
</div>
<p>For machine instruction selection, the better solution is represent IR and
machine instruction by DAG.
In <a class="pageref" href="#backendstructure-f8">Figure  8</a>, we skip the register leaf.
The rj + rk is IR DAG representation (for symbol notation, not llvm SSA form).
ADD is machine instruction.</p>
<div class="figure align-center" id="backendstructure-f8">
<img alt="_images/8.png" src="_images/8.png" />
<p class="caption">Figure 8: Instruction DAG representation</p>
</div>
<p>The IR DAG and machine instruction DAG can also represented as list.
For example, (+ ri, rj), (- ri, 1) are lists for IR DAG; (ADD ri, rj),
(SUBI ri, 1) are lists for machine instruction DAG.</p>
<p>Now, let&#8217;s recall the ADDiu instruction defined on Cpu0InstrInfo.td in the
previous chapter. List them again as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0InstrFormats.td</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Format L instruction class in Cpu0 : &lt;|opcode|ra|rb|cx|&gt;</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FL</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span>
         <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;:</span> <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmL</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">ra</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rb</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">imm16</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">20</span><span class="p">}</span> <span class="o">=</span> <span class="n">ra</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">19</span><span class="o">-</span><span class="mi">16</span><span class="p">}</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">15</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>  <span class="o">=</span> <span class="n">imm16</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Arithmetic and logical instructions with 2 register operands.
class ArithLogicI&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  Operand Od, PatLeaf imm_type, RegisterClass RC&gt; :
  FL&lt;op, (outs RC:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, "\t$ra, $rb, $imm16"),
     [(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; {
  let isReMaterializable = 1;
}
...
def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;</pre>
</div>
<p><a class="pageref" href="#backendstructure-f9">Figure  9</a> show how the pattern match work in the IR node
<strong>add</strong> and instruction ADDiu defined in Cpu0InstrInfo.td. For the example
IR node &#8220;add %a, 5&#8221;, will be translated to &#8220;addiu %r1, 5&#8221; since the IR
pattern[(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))] is set in ADDiu and the
2nd operand is signed immediate which matched &#8220;%a, 5&#8221;. In addition to pattern
match, the .td also set assembly string &#8220;addiu&#8221; and op code 0x09.
With this information, the LLVM TableGen will generate instruction both in
assembly and binary automatically (the binary instruction in obj file of ELF
format which will shown at later chapter).
Similarly, the machine instruction DAG node LD and ST can be got from IR DAG
node <strong>load</strong> and <strong>store</strong>.</p>
<div class="figure align-center" id="backendstructure-f9">
<img alt="_images/9.png" src="_images/9.png" />
<p class="caption">Figure 9: Pattern match for ADDiu instruction and IR node add</p>
</div>
<p>Some cpu/fpu (floating point processor) has multiply-and-add floating point
instruction, fmadd.
It can be represented by DAG list (fadd (fmul ra, rc), rb).
For this implementation, we can assign fmadd DAG pattern to instruction td as
follows,</p>
<div class="highlight-c++"><pre>def FMADDS : AForm_1&lt;59, 29,
          (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
          "fmadds $FRT, $FRA, $FRC, $FRB",
          [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
                       F4RC:$FRB))]&gt;;</pre>
</div>
<p>Similar with ADDiu, [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
F4RC:$FRB))] is the pattern which include node <strong>fmul</strong> and node <strong>fadd</strong>.</p>
<p>Now, for the following basic block notation IR and llvm SSA IR code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">...</span>

<span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">fmul</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span>
<span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fadd</span> <span class="o">%</span><span class="n">d</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The llvm SelectionDAG Optimization Phase (is part of Instruction Selection
Process) prefered to translate this 2 IR DAG node (fmul %a, %b) (fadd %d, %c)
into one machine instruction DAG node (<strong>fmadd</strong> %a, %c, %b), than translate
them into 2 machine instruction nodes <strong>fmul</strong> and <strong>fadd</strong>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fmadd</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>As you can see, the IR notation representation is easier to read then llvm SSA
IR form.
So, we  use the notation form in this book sometimes.</p>
<p>For the following basic block code,</p>
<div class="highlight-c++"><pre>a = b + c   // in notation IR form
d = a – d
%e = fmadd %a, %c, %b // in llvm SSA IR form</pre>
</div>
<p>We can apply <a class="pageref" href="#backendstructure-f7">Figure  7</a> Instruction tree pattern to get the
following machine code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">load</span>  <span class="n">rb</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">8</span><span class="p">);</span> <span class="c1">// assume b allocate in sp+8, sp is stack point register</span>
<span class="n">load</span>  <span class="n">rc</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">16</span><span class="p">);</span>
<span class="n">add</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rb</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
<span class="n">load</span>  <span class="n">rd</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">24</span><span class="p">);</span>
<span class="n">sub</span> <span class="n">rd</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rd</span><span class="p">;</span>
<span class="n">fmadd</span> <span class="n">re</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rb</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="add-cpu0dagtodagisel-class">
<h2>Add Cpu0DAGToDAGISel class<a class="headerlink" href="#add-cpu0dagtodagisel-class" title="Permalink to this headline">¶</a></h2>
<p>The IR DAG to machine instruction DAG transformation is introduced in the
previous section.
Now, let&#8217;s check what IR DAG node the file ch3.bc has. List ch3.ll as follows,</p>
<div class="highlight-c++"><pre>// ch3.ll
define i32 @main() nounwind uwtable {
%1 = alloca i32, align 4
store i32 0, i32* %1
ret i32 0
}</pre>
</div>
<p>As above, ch3.ll use the IR DAG node <strong>store</strong>, <strong>ret</strong>. Actually, it also use
<strong>add</strong> for sp (stack point) register adjust.
So, the definitions in Cpu0InstrInfo.td as follows is enough.
IR DAG is defined in file  include/llvm/Target/TargetSelectionDAG.td.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>//===----------------------------------------------------------------------===//

/// Load and Store Instructions
///  aligned
defm LD     : LoadM32&lt;0x01,  "ld",  load_a&gt;;
defm ST     : StoreM32&lt;0x02, "st",  store_a&gt;;

/// Arithmetic Instructions (ALU Immediate)
// IR "add" defined in include/llvm/Target/TargetSelectionDAG.td, line 315 (def add).
def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;

let isReturn=1, isTerminator=1, hasDelaySlot=1, isCodeGenOnly=1,
    isBarrier=1, hasCtrlDep=1 in
  def RET : FJ &lt;0x2C, (outs), (ins CPURegs:$target),
                "ret\t$target", [(Cpu0Ret CPURegs:$target)], IIBranch&gt;;

//===----------------------------------------------------------------------===//
</pre>
</div>
<p>Add class Cpu0DAGToDAGISel (Cpu0ISelDAGToDAG.cpp) to CMakeLists.txt, and add
following fragment to Cpu0TargetMachine.cpp,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_4/Cpu0TargetMachine.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="c1">// Install an instruction selector pass using</span>
<span class="c1">// the ISelDag to gen Cpu0 code.</span>
<span class="kt">bool</span> <span class="n">Cpu0PassConfig</span><span class="o">::</span><span class="n">addInstSelector</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">addPass</span><span class="p">(</span><span class="n">createCpu0ISelDag</span><span class="p">(</span><span class="n">getCpu0TargetMachine</span><span class="p">()));</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_4/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="c1">/// createCpu0ISelDag - This pass converts a legalized DAG into a</span>
<span class="c1">/// CPU0-specific DAG, ready for instruction scheduling.</span>
<span class="n">FunctionPass</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0ISelDag</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0DAGToDAGISel</span><span class="p">(</span><span class="n">TM</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>This version adding the following code in Cpu0InstInfo.cpp to enable debug
information which called by llvm at proper time.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_4/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="n">MachineInstr</span><span class="o">*</span>
<span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">emitFrameIndexDebugValue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIx</span><span class="p">,</span>
                                        <span class="n">uint64_t</span> <span class="n">Offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">MDNode</span> <span class="o">*</span><span class="n">MDPtr</span><span class="p">,</span>
                                        <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineInstrBuilder</span> <span class="n">MIB</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">DBG_VALUE</span><span class="p">))</span>
    <span class="p">.</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FrameIx</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">).</span><span class="n">addMetadata</span><span class="p">(</span><span class="n">MDPtr</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">&amp;*</span><span class="n">MIB</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Build Chapter3_4, run it, we find the error message in Chapter3_3 is gone.
The new error message for Chapter3_4 as follows,</p>
<div class="highlight-bash"><pre>118-165-78-230:InputFiles Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o
ch3.cpu0.s
...
Target didn't implement TargetInstrInfo::storeRegToStackSlot!
1.  Running pass 'Function Pass Manager' on module 'ch3.bc'.
2.  Running pass 'Prologue/Epilogue Insertion &amp; Frame Finalization' on function
'@main'
...</pre>
</div>
</div>
<div class="section" id="add-prologue-epilogue-functions">
<h2>Add Prologue/Epilogue functions<a class="headerlink" href="#add-prologue-epilogue-functions" title="Permalink to this headline">¶</a></h2>
<p>Following came from tricore_llvm.pdf section “4.4.2 Non-static Register
Information ”.</p>
<p>For some target architectures, some aspects of the target architecture’s
register set are dependent upon variable factors and have to be determined at
runtime.
As a consequence, they cannot be generated statically from a TableGen
description – although that would be possible for the bulk of them in the case
of the TriCore backend.
Among them are the following points:</p>
<ul class="simple">
<li>Callee-saved registers. Normally, the ABI specifies a set of registers that a</li>
</ul>
<p>function must save on entry and restore on return if their contents are
possibly modified during execution.</p>
<ul class="simple">
<li>Reserved registers. Although the set of unavailable registers is already</li>
</ul>
<p>defined in the TableGen file, TriCoreRegisterInfo contains a method that marks
all non-allocatable register numbers in a bit vector.</p>
<p>The following methods are implemented:</p>
<ul class="simple">
<li>emitPrologue() inserts prologue code at the beginning of a function. Thanks</li>
</ul>
<p>to TriCore’s context model, this is a trivial task as it is not required to
save any registers manually. The only thing that has to be done is reserving
space for the function’s stack frame by decrementing the stack pointer.
In addition, if the function needs a frame pointer, the frame register %a14 is
set to the old value of the stack pointer beforehand.</p>
<ul class="simple">
<li>emitEpilogue() is intended to emit instructions to destroy the stack frame</li>
</ul>
<p>and restore all previously saved registers before returning from a function.
However, as %a10 (stack pointer), %a11 (return address), and %a14 (frame
pointer, if any) are all part of the upper context, no epilogue code is needed
at all. All cleanup operations are performed implicitly by the ret instruction.</p>
<ul class="simple">
<li>eliminateFrameIndex() is called for each instruction that references a word</li>
</ul>
<p>of data in a stack slot. All previous passes of the code generator have been
addressing stack slots through an abstract frame index and an immediate offset.
The purpose of this function is to translate such a reference into a
register–offset pair. Depending on whether the machine function that contains
the instruction has a fixed or a variable stack frame, either the stack pointer
%a10 or the frame pointer %a14 is used as the base register.
The offset is computed accordingly.
<a class="pageref" href="#backendstructure-f10">Figure  10</a> demonstrates for both cases how a stack slot
is addressed.</p>
<p>If the addressing mode of the affected instruction cannot handle the address
because the offset is too large (the offset field has 10 bits for the BO
addressing mode and 16 bits for the BOL mode), a sequence of instructions is
emitted that explicitly computes the effective address.
Interim results are put into an unused address register.
If none is available, an already occupied address register is scavenged.
For this purpose, LLVM’s framework offers a class named RegScavenger that
takes care of all the details.</p>
<div class="figure align-center" id="backendstructure-f10">
<img alt="_images/10.png" src="_images/10.png" />
<p class="caption">Figure 10: Addressing of a variable a located on the stack.
If the stack frame has a variable size, slot must be addressed relative to
the frame pointer</p>
</div>
<p>We will explain the Prologue and Epilogue further by example code.
So for the following llvm IR code, Cpu0 back end will emit the corresponding
machine instructions as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>define i32 @main<span class="o">()</span> nounwind uwtable <span class="o">{</span>
  %1 <span class="o">=</span> alloca i32, align 4
  store i32 0, i32* %1
  ret i32 0
<span class="o">}</span>

  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch3.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>LLVM get the stack size by parsing IR and counting how many virtual registers
is assigned to local variables. After that, it call emitPrologue().
This function will emit machine instructions to adjust sp (stack pointer
register) for local variables since we don&#8217;t use fp (frame pointer register).
For our example, it will emit the instructions,</p>
<div class="highlight-c++"><pre>addiu $sp, $sp, -8</pre>
</div>
<p>The  emitEpilogue will emit “addiu  $sp, $sp, 8”, 8 is the stack size.</p>
<p>Since Instruction Selection and Register Allocation occurs before
Prologue/Epilogue Code Insertion, eliminateFrameIndex() is called after machine
instruction and real register allocated.
It translate the frame index of local variable (%1 and %2 in the following
example) into stack offset according the frame index order upward (stack grow
up downward from high address to low address, 0($sp) is the top, 52($sp) is the
bottom) as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>define i32 @main<span class="o">()</span> nounwind uwtable <span class="o">{</span>
     %1 <span class="o">=</span> alloca i32, align 4
     %2 <span class="o">=</span> alloca i32, align 4
    ...
    store i32 0, i32* %1
    store i32 5, i32* %2, align 4
    ...
    ret i32 <span class="nv">0</span>

<span class="o">=</span>&gt; <span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -56
<span class="nv">$tmp1</span>:
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$3</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>   // %1 is the first frame index <span class="nb">local </span>variable, so allocate
                    // in 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>   // %2 is the second frame index <span class="nb">local </span>variable, so
                    // allocate in 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ...
  ret <span class="nv">$lr</span>
</pre></div>
</div>
<p>The Prologue and Epilogue functions as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_5/Cpu0FrameLowering.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre>  <span class="kt">void</span> <span class="n">processFunctionBeforeCalleeSavedScan</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                            <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_5/Cpu0FrameLowering.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span>   <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span>    <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">Cpu0InstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span> <span class="o">=</span>
    <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpu0InstrInfo</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getInstrInfo</span><span class="p">());</span>
  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">MBBI</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">?</span> <span class="n">MBBI</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">()</span> <span class="o">:</span> <span class="n">DebugLoc</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ADDiu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">;</span>
  <span class="c1">// First, compute final stack size.</span>
  <span class="kt">unsigned</span> <span class="n">StackAlign</span> <span class="o">=</span> <span class="n">getStackAlignment</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">LocalVarAreaOffset</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getMaxCallFrameSize</span><span class="p">();</span>
  <span class="n">uint64_t</span> <span class="n">StackSize</span> <span class="o">=</span>  <span class="n">RoundUpToAlignment</span><span class="p">(</span><span class="n">LocalVarAreaOffset</span><span class="p">,</span> <span class="n">StackAlign</span><span class="p">)</span> <span class="o">+</span>
     <span class="n">RoundUpToAlignment</span><span class="p">(</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">(),</span> <span class="n">StackAlign</span><span class="p">);</span>

   <span class="c1">// Update stack size</span>
  <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">setStackSize</span><span class="p">(</span><span class="n">StackSize</span><span class="p">);</span>

  <span class="c1">// No need to allocate space on the stack.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">StackSize</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">adjustsStack</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>

  <span class="n">MachineModuleInfo</span> <span class="o">&amp;</span><span class="n">MMI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getMMI</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MachineMove</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Moves</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">getFrameMoves</span><span class="p">();</span>
  <span class="n">MachineLocation</span> <span class="n">DstML</span><span class="p">,</span> <span class="n">SrcML</span><span class="p">;</span>

  <span class="c1">// Adjust stack.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="n">StackSize</span><span class="p">))</span> <span class="c1">// addiu sp, sp, (-stacksize)</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDiu</span><span class="p">),</span> <span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">SP</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="o">-</span><span class="n">StackSize</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span> <span class="c1">// Expand immediate that doesn&#39;t fit in 16-bit.</span>
	<span class="n">assert</span><span class="p">(</span><span class="s">&quot;No expandLargeImm(SP, -StackSize, false, TII, MBB, MBBI, dl);&quot;</span><span class="p">);</span>
<span class="c1">//    expandLargeImm(SP, -StackSize, false, TII, MBB, MBBI, dl);</span>
  <span class="p">}</span>

  <span class="c1">// emit &quot;.cfi_def_cfa_offset StackSize&quot;</span>
  <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">AdjustSPLabel</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">getContext</span><span class="p">().</span><span class="n">CreateTempSymbol</span><span class="p">();</span>
  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span>
          <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">TargetOpcode</span><span class="o">::</span><span class="n">PROLOG_LABEL</span><span class="p">)).</span><span class="n">addSym</span><span class="p">(</span><span class="n">AdjustSPLabel</span><span class="p">);</span>
  <span class="n">DstML</span> <span class="o">=</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">MachineLocation</span><span class="o">::</span><span class="n">VirtualFP</span><span class="p">);</span>
  <span class="n">SrcML</span> <span class="o">=</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">MachineLocation</span><span class="o">::</span><span class="n">VirtualFP</span><span class="p">,</span> <span class="o">-</span><span class="n">StackSize</span><span class="p">);</span>
  <span class="n">Moves</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MachineMove</span><span class="p">(</span><span class="n">AdjustSPLabel</span><span class="p">,</span> <span class="n">DstML</span><span class="p">,</span> <span class="n">SrcML</span><span class="p">));</span>

  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Find the instruction past the last instruction that saves a callee-saved</span>
    <span class="c1">// register to the stack.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="o">++</span><span class="n">MBBI</span><span class="p">;</span>

    <span class="c1">// Iterate over list of callee-saved registers and emit .cfi_offset</span>
    <span class="c1">// directives.</span>
    <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">CSLabel</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">getContext</span><span class="p">().</span><span class="n">CreateTempSymbol</span><span class="p">();</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span>
            <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">TargetOpcode</span><span class="o">::</span><span class="n">PROLOG_LABEL</span><span class="p">)).</span><span class="n">addSym</span><span class="p">(</span><span class="n">CSLabel</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
           <span class="n">E</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">int64_t</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getFrameIdx</span><span class="p">());</span>
      <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getReg</span><span class="p">();</span>
      <span class="p">{</span>
        <span class="c1">// Reg is either in CPURegs or FGR32.</span>
        <span class="n">DstML</span> <span class="o">=</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">MachineLocation</span><span class="o">::</span><span class="n">VirtualFP</span><span class="p">,</span> <span class="n">Offset</span><span class="p">);</span>
        <span class="n">SrcML</span> <span class="o">=</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
        <span class="n">Moves</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MachineMove</span><span class="p">(</span><span class="n">CSLabel</span><span class="p">,</span> <span class="n">DstML</span><span class="p">,</span> <span class="n">SrcML</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">getLastNonDebugInstr</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span>            <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">Cpu0InstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span> <span class="o">=</span>
    <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpu0InstrInfo</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getInstrInfo</span><span class="p">());</span>
  <span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">MBBI</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ADDiu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">;</span>

  <span class="c1">// Get the number of bytes from FrameInfo</span>
  <span class="n">uint64_t</span> <span class="n">StackSize</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">StackSize</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Adjust stack.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">StackSize</span><span class="p">))</span> <span class="c1">// addiu sp, sp, (stacksize)</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDiu</span><span class="p">),</span> <span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">SP</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="n">StackSize</span><span class="p">);</span>
  <span class="k">else</span> <span class="c1">// Expand immediate that doesn&#39;t fit in 16-bit.</span>
	<span class="n">assert</span><span class="p">(</span><span class="s">&quot;No expandLargeImm(SP, StackSize, false, TII, MBB, MBBI, dl);&quot;</span><span class="p">);</span>
<span class="c1">//    expandLargeImm(SP, StackSize, false, TII, MBB, MBBI, dl);</span>

<span class="p">}</span>

<span class="c1">// This method is called immediately before PrologEpilogInserter scans the </span>
<span class="c1">//  physical registers used to determine what callee saved registers should be </span>
<span class="c1">//  spilled. This method is optional. </span>
<span class="c1">// Without this will have following errors,</span>
<span class="c1">//  Target didn&#39;t implement TargetInstrInfo::storeRegToStackSlot!</span>
<span class="c1">//  UNREACHABLE executed at /usr/local/llvm/3.1.test/cpu0/1/src/include/llvm/</span>
<span class="c1">//  Target/TargetInstrInfo.h:390!</span>
<span class="c1">//  Stack dump:</span>
<span class="c1">//  0.	Program arguments: /usr/local/llvm/3.1.test/cpu0/1/cmake_debug_build/</span>
<span class="c1">//  bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch0.bc -o </span>
<span class="c1">//  ch0.cpu0.s</span>
<span class="c1">//  1.	Running pass &#39;Function Pass Manager&#39; on module &#39;ch0.bc&#39;.</span>
<span class="c1">//  2.	Running pass &#39;Prologue/Epilogue Insertion &amp; Frame Finalization&#39; on </span>
<span class="c1">//      function &#39;@main&#39;</span>
<span class="c1">//  Aborted (core dumped)</span>

<span class="c1">// Must exist</span>
<span class="c1">//	ldi	$sp, $sp, 8</span>
<span class="c1">//-&gt;	ret	$lr</span>
<span class="c1">//	.set	macro</span>
<span class="c1">//	.set	reorder</span>
<span class="c1">//	.end	main</span>
<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span>
<span class="n">processFunctionBeforeCalleeSavedScan</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                     <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineRegisterInfo</span><span class="o">&amp;</span> <span class="n">MRI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">();</span>

  <span class="c1">// FIXME: remove this code if register allocator can correctly mark</span>
  <span class="c1">//        $fp and $ra used or unused.</span>

  <span class="c1">// The register allocator might determine $ra is used after seeing</span>
  <span class="c1">// instruction &quot;jr $ra&quot;, but we do not want PrologEpilogInserter to insert</span>
  <span class="c1">// instructions to save/restore $ra unless there is a function call.</span>
  <span class="c1">// To correct this, $ra is explicitly marked unused if there is no</span>
  <span class="c1">// function call.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasCalls</span><span class="p">())</span>
    <span class="n">MRI</span><span class="p">.</span><span class="n">setPhysRegUsed</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">MRI</span><span class="p">.</span><span class="n">setPhysRegUnused</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_5/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="c1">//- If eliminateFrameIndex() is empty, it will hang on run. </span>
<span class="c1">// pure virtual method</span>
<span class="c1">// FrameIndex represent objects inside a abstract stack.</span>
<span class="c1">// We must replace FrameIndex with an stack/frame pointer</span>
<span class="c1">// direct reference.</span>
<span class="kt">void</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span> <span class="o">=</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="o">*</span><span class="n">MI</span><span class="p">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>

  <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">isFI</span><span class="p">())</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MI</span><span class="p">.</span><span class="n">getNumOperands</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
           <span class="s">&quot;Instr doesn&#39;t have FrameIndex operand!&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Function : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;---------&gt;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MI</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">FrameIndex</span> <span class="o">=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">getIndex</span><span class="p">();</span>
  <span class="n">uint64_t</span> <span class="n">stackSize</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">();</span>
  <span class="n">int64_t</span> <span class="n">spOffset</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">);</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;FrameIndex : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">FrameIndex</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot;spOffset   : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">spOffset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot;stackSize  : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">stackSize</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">MinCSFI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">MaxCSFI</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">MinCSFI</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">();</span>
    <span class="n">MaxCSFI</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// The following stack frame objects are always referenced relative to $sp:</span>
  <span class="c1">//  1. Outgoing arguments.</span>
  <span class="c1">//  2. Pointer to dynamically allocated stack space.</span>
  <span class="c1">//  3. Locations for callee-saved registers.</span>
  <span class="c1">// Everything else is referenced relative to whatever register</span>
  <span class="c1">// getFrameRegister() returns.</span>
  <span class="kt">unsigned</span> <span class="n">FrameReg</span><span class="p">;</span>

    <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">getFrameRegister</span><span class="p">(</span><span class="n">MF</span><span class="p">);</span>

  <span class="c1">// Calculate final offset.</span>
  <span class="c1">// - There is no need to change the offset if the frame object is one of the</span>
  <span class="c1">//   following: an outgoing argument, pointer to a dynamically allocated</span>
  <span class="c1">//   stack space or a $gp restore location,</span>
  <span class="c1">// - If the frame object is any of the following, its offset must be adjusted</span>
  <span class="c1">//   by adding the size of the stack:</span>
  <span class="c1">//   incoming argument, callee-saved register location or local variable.</span>
  <span class="n">int64_t</span> <span class="n">Offset</span><span class="p">;</span>
  <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">int64_t</span><span class="p">)</span><span class="n">stackSize</span><span class="p">;</span>

  <span class="n">Offset</span>    <span class="o">+=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">getImm</span><span class="p">();</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Offset     : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Offset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;---------&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="c1">// If MI is not a debug value, make sure Offset fits in the 16-bit immediate</span>
  <span class="c1">// field.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MI</span><span class="p">.</span><span class="n">isDebugValue</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Offset</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">assert</span><span class="p">(</span><span class="s">&quot;(!MI.isDebugValue() &amp;&amp; !isInt&lt;16&gt;(Offset))&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">ChangeToRegister</span><span class="p">(</span><span class="n">FrameReg</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
  <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">ChangeToImmediate</span><span class="p">(</span><span class="n">Offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
</pre></div>
</td></tr></table></div>
<p>After add these Prologue and Epilogue functions, and build with Chapter3_5/Cpu0.
Now we are ready to compile our example code ch3.bc into cpu0 assembly code.
Following is the command and output file ch3.cpu0.s,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>cat ch3.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch3.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
</div>
<div class="section" id="summary-of-this-chapter">
<h2>Summary of this Chapter<a class="headerlink" href="#summary-of-this-chapter" title="Permalink to this headline">¶</a></h2>
<p>We have finished a simple assembler for cpu0 which only support <strong>addiu</strong>,
<strong>st</strong> and <strong>ret</strong> 3 instructions.</p>
<p>We are satisfied with this result.
But you may think “After so many codes we program, and just get the 3
instructions”.
The point is we have created a frame work for cpu0 target machine (please
look back the llvm back end structure class inherit tree early in this
chapter).
Until now, we have around 3050 lines of source code with comments which include
files *.cpp, *.h, *.td, CMakeLists.txt and LLVMBuild.txt.
It can be counted by command <tt class="docutils literal"><span class="pre">wc</span> <span class="pre">`find</span> <span class="pre">dir</span> <span class="pre">-name</span> <span class="pre">*.cpp`</span></tt> for files *.cpp,
*.h, *.td, *.txt.
LLVM front end tutorial have 700 lines of source code without comments totally.
Don&#8217;t feel down with this result.
In reality, write a back end is warm up slowly but run fast.
Clang has over 500,000 lines of source code with comments in clang/lib
directory which include C++ and Obj C support.
Mips back end has only 15,000 lines with comments.
Even the complicate X86 CPU which CISC outside and RISC inside (micro
instruction), has only 45,000 lines with comments.
In next chapter, we will show you that add a new instruction support is as easy
as 123.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine">http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://jonathan2251.github.com/lbd/llvmstructure.html#target-registration">http://jonathan2251.github.com/lbd/llvmstructure.html#target-registration</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">http://llvm.org/docs/CodeGenerator.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="llvmstructure.html">Cpu0 Instruction Set and LLVM Target Description</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="otherinst.html">Adding arithmetic and local pointer support</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>